#! /bin/bash
# Copyright: see comments below and the notice displayed during runtime for the details
# PROJECT NAME: POOFITEE: "almost Perfect Owner Only access linux Firewall - the system is Invisible To Everyone Else" 
# TODO: CURRENTLY UNDERWAY: converting from shell script backup ruleset to iptables-type save/restore.  
# TODO: convert to CIDR address consolidation where port and tcp flags for individual addresses would be tracked in a separate file instead of in the iptables rule.
# TODO: Get remainder of menu options finished, started writing rules for loose knocking
# TODO: accommodate other countries' different date, etc. formatting preferences in log files, directory listings, etc.
# TODO: Replicate not getting email even when port 1958 knocked, then fix
# TODO: Firewalling options this install script should be able to alter from the script set defaults:
# TODO: -- Stop probe logging/blacklisting to save space or if you're just not curious - comment out the crontab entry and kill the process
# TODO: -- Open specific ports to offer public services
# TODO: -- Force single-interface firewalling even though two interfaces exist
# TODO: -- Alter the IP address of the private-side interface from 192.168.3.1
# TODO: Testing using DHCP client and server on the private interface
# TODO: WARNING -- NEVER PIPE THE OUTPUT OF 'IPTABLES -L' INTO 'LESS' OR YOU MAY LOSE ENTIRE CHAINS IN IPTABLES!
# TODO: check for sufficient resources prior to executing, like disk space
# TODO: fix postfix log errs about badly named email account if full install doesn't and make more secure with smtp_tls_per_site, 
# TODO: make user poofitee that cron jobs run under, suggest /home/poofitee as the installation directory, but when user is made, use the home directory accepted by the installing operator
# TODO: adduser -G root poofitee;passwd poofitee
# replace initd with systemd when referencing iptables-persistent and postfix
# replace iptables with nftables
# before anything that requires iptables to be persistent is started, make sure iptables is persistently configured
# init.d doesn't seem to be restoring: line in syslog=Jun 13 06:50:24 firewall netfilter-persistent[417]: run-parts: executing /usr/share/netfilter-persistent/plugins.d/15-ip4tables start
# --->  	if [ ! -f /etc/iptables/rules.v4 ]; then
#		echo "Warning: skipping IPv4 (no rules to load)"
#	else
#		iptables-restore < /etc/iptables/rules.v4 2> /dev/null
#		if [ $? -ne 0 ]; then
# look in /home/homeowner/iptables.log after next reboot
#/etc/postfix/main.cf
#
#. . .
#mailbox_size_limit = 0
#recipient_delimiter = +
#inet_interfaces = all
#. . .
#
#Change the line that reads inet_interfaces = all to inet_interfaces = loopback-only.
# Options:
# Email parser on/off
#  --- email address, password
#  --- command set (suggest default set, allow deletes, adds and mods)
#
# firewall on/off
#   --- check if dual interface, allow select of dual from display of suggested
#   --- determine private IP range, allow for changing
#   --- track first time probers (forms dynamic blacklist or file)
#   ---  build  iptables rules reconstructer shell script
#   ---  suggest starter iptables ruleset scenario, allowing for blacklist or whitelist to have higher pwr
#   ---- get list of alert email destinations with authenticating email addr and pw
#  --- allow option for always-on ports like 80
#  --- don't forget persistence
#
# dhcp notifier on/off
#   ---- get list of alert email destinations with authenticating email addr and pw
#
# test emailing while setting up
#
# remind about ssh keys
#
# set up port knocking
#  ---- normal port knocking
#   ---- port knocking with lookup table
#   ---- port knock to fetch remote controlling email
#
#  accommodate reconfiguration of already installed system
#
#    Arrangement for your freedom from copyright display obligation: Prior to
#  distribution, email me the author: kenlovesjesus at gmail dot com to arrange USD payment.
#  You'll insert name and details of party responsible for making the payment to the
#  author into comments in the script's sourcecode.  I, the author, will only give
#  you permission to free yourself from copyright display obligation in writing addressed
#  directly to the party making payment to me after you have made contact with me.
#  End of copyright message
#
#
# POOFITEE firewall install helper script layout
#

################  FUNCTIONS FIRST, THEN MAIN:
back_up_iptables_ruleset () {
printf "\nPlease wait while your $1 iptables ruleset is backed up..."
while current_time="$(date)";[[ -f "$directoryforscripts/iptables_ruleset.$current_time" ]];do
     sleep 1
done
$iptablespath-save > "$directoryforscripts/iptables_ruleset.$current_time" 
backup_result="$?"
printf "\nA copy of your $1 iptables ruleset is backed up in\
\n\n$directoryforscripts/iptables_ruleset.$current_time\n\n"
return $(($backup_result))
}
find_first_reference_to_internal_interface () {
if ! [[ -z "$internal_net_interface" ]];then
     $iptablespath -wN poofitee_knockerstest 2>/dev/null # ;echo "$?") == "0" ]] || printf "Failed"
     [[ $($iptablespath -wF poofitee_knockerstest 2>/dev/null;echo "$?") == "0" ]] || printf "Failed to flush knockerstest chain rules"
     printf "\n"
     printf "" > internal_interfaces_referenced # won't include the default gateway
# test knock rules belonging in the INPUT chain need to be located just prior to any other reference to that private interface or any of the addresses associated with such interface
#SEARCH FOR ADDRESSES EVEN IF INTERFACE REFERENCE IS FOUND SO CAN KNOW THE FIRST LINE EITHER ONE OCCURS IN.
     echo "$internal_net_interface"|$awkpath '{print $1}' \
     |while read interface; do
          $iptablespath -wnvL INPUT --line-number \
          |$awkpath 'NR>2 {print $1" "$7" "$9}' \
          |while read linenum_intfc_src_addr_in_input_chain; do
                    linenum_in_input_chain="${linenum_intfc_src_addr_in_input_chain%% *}"
                    intfc_src_addr_in_input_chain="${linenum_intfc_src_addr_in_input_chain#* }"
                    intfc_in_input_chain="${intfc_src_addr_in_input_chain% *}"   # echo "$src_addr_in_input_chain | $linenum_in_input_chain | $intfc_in_input_chain";
                    src_addr_in_input_chain="${intfc_src_addr_in_input_chain#* }"; src_addr_in_input_chain="${src_addr_in_input_chain%/*}"
            # the next search is to locate references of the internal interface under scrutiny in each line of chain in route table
                    if [[ $(($($ippath route show|$greppath $intfc_in_input_chain|$greppath -c default))) -eq 0 ]];
                    then echo "$linenum_in_input_chain $intfc_in_input_chain" >> internal_interfaces_referenced
                    elif ! [[ "$src_addr_in_input_chain" == "0.0.0.0" ]];then # we assume if finding by address, route tables are already set up
# determine address range[s] routed out that interface and check for input chain references to any of them 
#   using $ippath route show|$greppath $internal_net_interface|$awkpath '{print $1}' -> convert each line 
#   to binary which gives one or more lines of address ranges to match to ip addresses referenced in INPUT chain to, /32 = no / at all.  Abort operation if private interface is also default
                         $ippath route show|$greppath -v default|$greppath $interface \
                         |while read line; do 
                              line="${line%% *}/32"
                              range_start="${line%%/*}"
                         [[ $(printf "$range_start\n$src_addr_in_input_chain"|$sortpath -V|$tailpath -n1) == "$src_addr_in_input_chain" ]] || break
                         cidr_bits="${line#*/}"
                         cidr_bits="${line%%/*}"
                         src_addr_in_input_chain_seg1="${src_addr_in_input_chain%%.*}"
                         range_start_seg1="${range_start%%.*}"
                         src_addr_in_input_chain="${src_addr_in_input_chain#*.}"
                         range_start="${range_start#*.}"
                         src_addr_in_input_chain_seg2="${src_addr_in_input_chain%%.*}"
                         range_start_seg2="${range_start%%.*}"
                         src_addr_in_input_chain="${src_addr_in_input_chain#*.}"
                         range_start="${range_start#*.}"
                         src_addr_in_input_chain_seg3="${src_addr_in_input_chain%%.*}"
                         range_start_seg3="${range_start%%.*}"
                         src_addr_in_input_chain="${src_addr_in_input_chain#*.}"
                         range_start="${range_start#*.}"
                         src_addr_in_input_chain_seg4="${src_addr_in_input_chain%%.*}"
                         range_start_seg4="${range_start%%.*}"
                         doubler=1
                         for ((j=$((32 - $cidr_bits));j>0;j--)); do
                              doubler=$(( $doubler * 2 ))
                         done
                         range_end=$(( ($range_start_seg1 * 256 * 256 * 256) + ($range_start_seg2 * 256 * 256) + ($range_start_seg3 * 256) + $range_start_seg4 + $doubler -1 ))
                         src_addr_in_input_chain=$(( ($src_addr_in_input_chain_seg1 * 256 * 256 * 256) + ($src_addr_in_input_chain_seg2 * 256 * 256) + ($src_addr_in_input_chain_seg3 * 256) + $src_addr_in_input_chain_seg4 ))
                         if [[ "$(printf "$range_end\n$src_addr_in_input_chain"|$sortpath -n|$tailpath -n1)" == "$range_end" ]];then
                              #   echo "within range"
                              "$linenum_in_input_chain $intfc_in_input_chain" >> internal_interfaces_referenced
                         fi
                    done
               fi
          done
     done
     linenumber_for_inserting_before=$(($($sortpath -k1 < internal_interfaces_referenced|$awkpath '{if (NR==1) {print $1}}')))
     [[ "$linenumber_for_inserting_before" == "0" ]] && linenumber_for_inserting_before="1"
     if ! [[ -z "$($greppath ^Port /etc/ssh/sshd_config|$awkpath '{print $2}')" ]]; then
          [[ $($iptablespath -wI INPUT $linenumber_for_inserting_before -i $(echo "$internal_net_interface"|$xargspath|$awkpath '{print $1}') -p tcp --dport $($greppath ^Port /etc/ssh/sshd_config|$awkpath '{print $2}') -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT -m comment --comment "poofitee_knock extract ssh for knock testg frm private side in ssh" 2>/dev/null;echo "$?") == "0" ]] && linenumber_for_inserting_before=$(( $linenumber_for_inserting_before + 1 )) || printf "Failed 14"
     fi
     line_number_for_authorized_rule=$linenumber_for_inserting_before
fi
}
get_operator_knock_choices () {
                 minimum_number_of_knocks="$([[ "x$1$2$3" =~ unique ]] && echo "4" || echo "2")"
                 $iptablespath -wN poofitee_ruletestchain 2>/dev/null # This chain is merely a place to pre-test whether a rule will be accepted by iptables or not
                 $iptablespath -wF poofitee_ruletestchain 2>/dev/null # This chain is merely a place to pre-test whether a rule will be accepted by iptables or not
                 i=1
                 while knockport[$i]="";printf "\n";read -e -p "Knock $i port:" knockport[$i];! [[ -z "${knockport[$i]}" ]] || [[ $(($i)) -le $(($minimum_number_of_knocks)) ]];do
                      [[ -z "${knockport[$i]}" ]] && printf " You need to specify at least $minimum_number_of_knocks knocks" && continue
                      if ! [[ "${knockport[$i]}" =~ ^[0-9]{1,5}$ ]] || ! [[ $(( ${knockport[$i]} )) -le 65535 ]] || [[ -z "${knockport[$i]}" ]] ;then continue;fi
                      if ! [[ -z "$internal_net_interface" ]] && [[ -f "/etc/ssh/sshd_config" ]] && [[ "$($greppath ^Port /etc/ssh/sshd_config|$awkpath '{print $2}')" =~ [0-9] ]] && [[ " ${knockport[$i]} " =~ \ $($greppath ^Port /etc/ssh/sshd_config|$awkpath '{print $2}')\  ]];then
                         printf "You are advised against specifying your ssh port "$(printf "("$($greppath ^Port /etc/ssh/sshd_config|$awkpath \
'{printf $2}')")")" simply because it will\
\ninterfere with you testing your sequence through an ssh session.  Do you still\
\nwant to specify this port? (y/n) ";read  -rn1;read -rst 0.001 -n3 discard;! [[ $REPLY =~ [Yy] ]] && continue
                      fi
                      printf "\nKnock $i protocol (choose from \"all\" [any protocol is acceptable] or those listed\
\nin /etc/protocols.  TCP with SYN flag is defaulted below and will function if\
\nyou don\'t care to get any fancier.  You may include mask-flag spec or other\
\niptables matching options beyond this, if you know them, except the -j target,\
\n-g chain, -m recent, and -m comment iptables modules/options):\n\
\n";knockproto[$i]="-p tcp --syn ";read -e -i "${knockproto[$i]}" knockproto[$i]
                      testtarget[$i]=" -j DROP"
                      if [[ "${knockproto[$i]}" =~ \ --tcp-flags\ .*ACK\ .*ACK ]] ; then
#                      if [[ "${knockproto[$i]}" =~ \ --tcp-flags\ *[^[:space:]g]*\ *ACK\  ]] ; then
                           until false; do
                                if ! [[ -z "$if_first_knock_is_ACK_message" ]] && [[ "$i" == "1" ]];then
                                     printf "$if_first_knock_is_ACK_message"
                                     read -rn 1;read -rst 0.001 -n3 discard
                                     [[ $REPLY =~ [Rr] ]] && continue 2
                                     ! [[ $REPLY =~ [Kk] ]] && break
                                else
                                     printf "You've specified a packet type that would generate a reply of some type from the\
\nserver in normal communications.  To help disguise the knock packet from packet\
\nsniffing hackers so it looks like a normal communication packet, do you want the\
\nserver to reply to this knock (with a REJECT$(! [[ -z "$if_first_knock_is_ACK_message" ]] && \
printf ", and of course only if the previous\nknocks in the sequence have been received correctly)" || printf ")")? (y/n): "
                                     read -rn 1;read -rst 0.001 -n3 discard
                                     if ! [[ $REPLY =~ [Yy] ]]; then
                                          [[ $REPLY =~ [Nn] ]] && break
                                          continue
                                     fi
                                fi
                                testtarget[$i]=" -j REJECT --reject-with tcp-reset"
                                break
                           done
                      fi
                      protovar="${knockproto[$i]}"
                      protovar="${protovar:1}"
                      knockproto[$i]="-${protovar%%-*} --dport ${knockport[$i]} -${protovar#*-}" #combines both never again to need port kept separate for rule-making
                      if ! [[ $($iptablespath -wA poofitee_ruletestchain ${knockproto[$i]}${testtarget[$i]} ;echo "$?") == "0" ]];then
                          printf -- "Your ${knockproto[$i]} is not crafted well enough, try again\n"
                          continue
                      fi
                      if [[ "x$1$2$3" =~ unique ]] && ! [[ "$(i=1;while ! [[ -z "${knockproto[$i]}" ]];do printf -- "${knockproto[$i]}";printf "\n";i=$(($i + 1));done|$sortpath|$uniqpath -d|wc -l)" == "0" ]];then
                          printf -- "\nYour ${knockproto[$i]} is required to be unique and is not, try again\n"
                          continue
                      fi
                      i=$(( $i+1 ));[[ $(( $i )) -gt 16 ]] && break
                 done
}
move_cursor_to_next_entry_in_list () {
line=""
echo
linesfrommaster="$toemailaddsmaster"
if ! [[ $(( $mstrlinenumber )) -gt $(( $mstrnumoflines )) ]];then
     if  [[ $(( $mstrlinenumber )) -lt 2 ]];then
          line="${linesfrommaster%%,*}" # set to next line in master
          printf "\r$line\033[K"
          return
     fi
     loopmstrptr=1
     until loopmstrptr="$(( $loopmstrptr  + 1 ))";linesfrommaster="${linesfrommaster#*,}";[[ -z "$linesfrommaster" ]] || [[ $(( $loopmstrptr  )) -gt $(( $mstrnumoflines )) ]];do
         [[ $(( $loopmstrptr  )) -lt $(( $mstrlinenumber )) ]] && continue
         entriesscratchpad="$(printf "$toemailadds"|$awkpath 1 ORS=',')"
         while ! [[ -z "$entriesscratchpad" ]] && ! [[ -z "${linesfrommaster%%,*}" ]] && ! [[ "${entriesscratchpad%%,*}" == "${linesfrommaster%%,*}" ]];do
             entriesscratchpad="${entriesscratchpad#*,}" # gets the next line from slave
         done
         [[ -z "$entriesscratchpad" ]] || [[ -z "${linesfrommaster%%,*}" ]] && break
         [[ "${entriesscratchpad%%,*}" == "${linesfrommaster%%,*}" ]] && ( linesfrommaster="${linesfrommaster#*,}";continue )
     done
     line="${linesfrommaster%%,*}" # set to next line in master
     [[ "${entriesscratchpad%%,*}" == "${linesfrommaster%%,*}" ]] && line=""
      printf "\r$line\033[K"
else
      printf "\033[K"
fi
}
get_sendto_emailadds () {  # can take one optional arg, "onlyneed1" which will change behavior from taking numerous entries, storing them in variable toemailadds to either taking one entry or selecting one entry from previous list and storing it in variable mailadd
     [[ -z "$directoryforscripts" ]] && directoryforscripts="$( [[ -f directoryforscripts ]] && cat directoryforscripts || printf "/home/poofitee")"
     line=""
     if [[ -f "$directoryforscripts/toemailadds" ]];then
           line="$(cat "$directoryforscripts/toemailadds")"
     elif [[ -f "./toemailadds" ]];then
           line="$(cat "./toemailadds")"
     fi
     toemailaddsmaster="$line"
     mstrlinenumber=1
     mstrnumoflines=$( echo "$toemailaddsmaster"|$sedpath 's/,/\n/g'|$wcpath -l )
     line="${line%%,*}"         # not real sure where the best place is for these lines.  Prior to while loop maybe?
     ! [[ -z "$line" ]] && printf "$(echo "$toemailaddsmaster"|$sedpath 's/,/\n/g')\n\033["$mstrnumoflines"A\r$line\033[K"
     toemailadds=""

     while IFS= read -s -n1 -r char;do # [[ -z "$char" ]] && break
          if [[ "$(printf "%d" "'$char")" == "27" ]];then # 'escape or extended key has been detected, single quote is important
                     if [[ $(read -rst 0.001 -n1;echo $REPLY) == "[" ]];then
                           read -rst 0.001 -n1;read -rst 0.001 -n1 discard
                           if [[ "$REPLY" == "B" ]] && ! [[ $(( $mstrlinenumber )) -gt $(( $mstrnumoflines )) ]];then #down-arrow pressed
                                mstrlinenumber="$(( $mstrlinenumber + 1 ))"
                                move_cursor_to_next_entry_in_list
                           elif [[ "$REPLY" == "A" ]] && [[ $(( $mstrlinenumber )) -gt 1 ]];then #up-arrow pressed
                                printf "\033[2A"
                                mstrlinenumber="$(( $mstrlinenumber - 1 ))"
                                move_cursor_to_next_entry_in_list
                           fi
                     else
                         read -rst 0.001 -n2 # read & discard 2nd extended key field, timeout if real escape
                     fi
          elif [[ -z "$char" ]] || [[ "$char" == " " ]];then
                      if [[ -z "$line" ]] && [[ $(( $mstrlinenumber )) -lt $(( $mstrnumoflines )) ]];then
# Shift and display next from master on this line 
                           linesfrommaster="$toemailaddsmaster"
                           mstrlinenumber="$(( $mstrlinenumber + 1 ))"
                           loopmstrptr=1
                           until loopmstrptr="$(( $loopmstrptr  + 1 ))";linesfrommaster="${linesfrommaster#*,}";[[ -z "$linesfrommaster" ]] || [[ $(( $loopmstrptr  )) -gt $(( $mstrnumoflines )) ]];do
                               [[ $(( $loopmstrptr  )) -lt $(( $mstrlinenumber )) ]] && continue
                               entriesscratchpad="$(printf "$toemailadds"|$awkpath 1 ORS=',')"
                               while ! [[ -z "$entriesscratchpad" ]] && ! [[ -z "${linesfrommaster%%,*}" ]] && ! [[ "${entriesscratchpad%%,*}" == "${linesfrommaster%%,*}" ]];do
                                   entriesscratchpad="${entriesscratchpad#*,}" # gets the next line from slave
                               done
                               [[ -z "$entriesscratchpad" ]] || [[ -z "${linesfrommaster%%,*}" ]] && break
                               [[ "${entriesscratchpad%%,*}" == "${linesfrommaster%%,*}" ]] && ( linesfrommaster="${linesfrommaster#*,}";continue )
                           done
                           line="${linesfrommaster%%,*}" # set to next line in master that is not duplicated in slave var
                           [[ "${entriesscratchpad%%,*}" == "${linesfrommaster%%,*}" ]] && line=""
                           printf "\r$line\033[K"
                      elif ! [[ -z "$line" ]];then
                          if ! [[ "$line" =~ ^(([-a-zA-Z0-9\!#\$%\&\'*+/=?^_\`{\|}~]+|(\"([][,:;<>\&@a-zA-Z0-9\!#\$%\&\'*+/=?^_\`{\|}~-]|(\\\\[\\ \"]))+\"))\.)*([-a-zA-Z0-9\!#\$%\&\'*+/=?^_\`{\|}~]+|(\"([][,:;<>\&@a-zA-Z0-9\!#\$%\&\'*+/=?^_\`{\|}~-]|(\\\\[\\ \"]))+\"))+@[A-Za-z0-9.-]+\.[A-Za-z]{2,4}$ ]];then
                              printf " checked bad, use backspace to correct\r$line"
                          else #this is the place where operator installing has entered an email address and pressed enter or space
                              if [[ "$1" == "onlyneed1" ]];then mailadd="$line";for ((i=$(( $mstrlinenumber ));i<=$(( $mstrnumoflines ));i++));do printf "\r\033[B\033[K";done;for ((i=1;i<=$(( $mstrnumoflines ));i++));do printf "\r\033[A\033[K";done;return;fi
                              toemailadds+="$line\n"
                              mstrlinenumber="$(( $mstrlinenumber + 1 ))"
                              move_cursor_to_next_entry_in_list
                          fi
                      elif [[ -z "$1" ]];then
#                          printf "\033[K"  # if ever needed
                          break
                      fi
          elif [[ "$(printf "%d" "'$char")" == "127" ]];then # ' backspace pressed
                     if ! [[ -z "$line" ]];then
                         line="${line:0: -1}" # handles the backspace character
                         printf "\r$line\033[K" # needed b/c when several keys are pressed simultaneously only first gets silented
                     fi
          else
                          printf "$char";
                          line+="$char"
          fi
     done
     if ! [[ -z $toemailadds ]] && [[ -z "$1" ]];then
         directoryforscripts="$( cat directoryforscripts )"
         toemailaddsforfiling="$(printf "$toemailadds"|$awkpath 1 ORS=',')"
         [[ "${toemailaddsforfiling: -1}" == "," ]] && toemailaddsforfiling="${toemailaddsforfiling:: -1}"
         printf "$(printf "$toemailaddsforfiling\n")" > "$directoryforscripts/toemailadds"
         break
     fi

}
install_port_knocking () {
            REPLY=""
            until [[ "$REPLY" =~ [yn] ]]; do
               echo "The OTF feature is not yet finished.  Don't count on it..."
               read -e -r -n1 -p "Use OTPs (One-Time-Passwords)? (y, n, or ? for help) Client side is not free:"
               REPLY="${REPLY,}"
               [[ "$REPLY" =~ \? ]] && ( \
printf "\n  Client configuration is available under different licensing terms if you need\
\nus to do it for you.  Thank you...\
\n  Using One-Time-Passwords (OTPs) thwarts record-and-replay security attacks.\
\nIf hackers record your port knocks, their attempts to replay the knock sequence\
\nwith a previously used password (or wrong one or none at all) will, instead of\
\ngiving them access to your system, broadcast an email &/or SMS alert for you. An\
\ninvalid OTP submitted after successful port knocking positively identifies\
\npurposeful targeted contact.  Non-knocking firewall configurations, such as\
\nsimple SPA, lack this definity and may also be more vulnerable to memory\
\nexhaustion under DoS attack.  Your peace of mind from knowing if hacking at that\
\nlevel of sophistication is ever even attempted is priceless & worth the packets.\
\n  You create an OTP list of single-use passwords and supply it to the trusting\
\ndevice (this server) and to trusted devices and/or persons using some form of\
\nout-of-band communication (private connection, email, thumbdrive, etc.).  The\
\nOTP list can have not just one, but multiple OTPs for each label, so the trusted\
\nknockers can choose or be assigned unique and different security access levels.\
\nWhen the list of OTPs gets used up or nearly so, a notification email is sent to\
\nremind you to distribute a new OTP list.  The old OTP list just recirculates\
\nuntil replaced...used OTPs will get used again until you get time to generate a\
\nnew OTP list and give everyone a copy of it. Thus, it will be YOUR\
\nresponsibility to enforce a single-use-only policy on OTPs if you really need\
\nthat extreme level of security.  With the encryption depth and options allowed,\
\nyou may elect to let an OTP list be used more than once without serious risk of\
\ncompromise, especially with unrecognizable OTPs.";read -s -n1 -p "   (Press key...)";\
printf "\n  The OTP list is a non-encrypted text file: the first line is simply the month-\
\nyear number pair (includes the dash) the OTP list is created, a <comma> or\
\n<comma><space>, followed by a <comma> or <comma><space> delimited list of\
\nencryption methods and keys to rotate through, one per month.  TCP and UDP\
\nencryptions are allowed, as are multiple encryptions.\
\n  The template for each line after line 1 is:\
\n\nlabel<space>class n password<space>class n+1 password, etc.\
\n\n  Over- or under-encrypted OTPs are suggested to mask actual encryption level,\
\nor just use randomized character strings.\
\n  The server will initiate encryption handshaking only with a successful\
\nclient knocker.  Handshaking is as follows:  The server tells each successful\
\nknocker (client) what month-year their communication is taking place in.  Both\
\nends then negotiate the \"encryption of the month\".  The server then challenges\
\nthe client with a packet containing a label it chooses from the OTP list.  The\
\nclient must reply with the OTP associated with both that label and the access\
\nlevel they expect.  Sharing the set of OTPs between multiple devices is thus\
\naccommodated, as is security level assignment.\
\n  To make under-encrypted OTPs, run decryption on each non-encrypted OTP.  To\
\nover-encrypt, use OTPs that you've encrypted extra times beyond what your OTP\
\nlist specifies.";\
                   read -s -n1 -p "   (Press key...)";\
printf "\n\
\n\n  You may arrange for purchase and installation of client-side scripts (Linux/\
\nMac), programs (Linux/Mac/MS Windows/Android/iPhone), and OTP lists via email:\
\n\n                       kenlovesjesus at gmail dot com\
\n\n  Please allow for the possibility of some coding being done to order rather\
\nthan being ready made.  Most common payment forms welcome, and we will work\
\nwithin any reasonable purchasing protocol you need us to.  We try hard to speak\
\nto you on your level, novice to expert.\
\n  Developers: we encourage you to to create your own OTPs or client scripts and\
\nprograms.  We have tried to provide you with enough information to enable you to\
\ndo so, but if you need more, just ask us.  Be aware that actual client-side code\
\nis licensed under different terms and is charged for.\
\n  Homeowners: this project is being done with your Internet access, automation,\
\nsurveillance, and remote access needs in mind, so we welcome you! \n";\
continue)\
               || [[ "$REPLY" =~ n ]] \
               || ( [[ "$REPLY" =~ y ]] && (
#                      echo "Selected OTPs"
# Set up alert emails if not done already TODO: Make function, integrate better for answer scenarios
                   until [[ -f "$REPLY" ]];do
                        printf "\nEnter the name including absolute path of the OTP text file you're providing:\n"
#                   echo "Sorry, this feature is not yet finished...Press a key"
#                   read -sn1
                        read 
                        ! [[ -f "$REPLY" ]] && continue
                   done
                   cp "$REPLY" "$directoryforscripts"
                   continue
                   conf_postfix
                     )
                 )
            done
<<-HOLD_UNTIL_ABLE
\n  We can provide OTP lists to you for a nominal fee.  You just change/re-order\
\nthe labels, if you wish, to ensure your security.  Better yet for you, get\
\nthem yourself for FREE from online sources that advertise themselves as \"Ultra\
\nHigh Security Password Generator\"s.  Thank you...";
HOLD_UNTIL_ABLE
            until [[ "$REPLY" =~ [ls] ]]; do
             printf "Use loose (l) or strict (s) port knocking rules? (? for help) ";read -e -r -n1
             REPLY="${REPLY,}"
             [[ "$REPLY" == \? ]] && \
( printf "\
\n   You will select 2 to 16 port-protocol combinations (knocks) that you are\
\ndemanding be \"knocked\" by computers trying to establish communication to this\
\none through the Internet-facing interface that will prove their\
\nauthorization to connect.\
\n   l) loose knock rules are when you are permitting knocks to arrive here out of\
\nsequence or not arrive at all, given at least 4 valid port-protocol knocks, all\
\nunique from each other, do arrive.  Of course, to select this, you'll have to\
\nspecify a minimum of 4 port-protocol combinations, all unique from each other.\
\nThis option can reduce frustration for you if you consider yourself a low-value\
\ntarget for hackers and are taking all the other reasonable security measures\
\nanyway.  The order which you specify the port-protocol knocks in the sequence\
\nwill be irrelevant, and the 4 knocks must arrive in a total time frame of 12\
\nseconds times the total number of port-protocol combinations you specify. Knocks\
\non other ports during the knocking authentication period WILL BE ALLOWED.  The\
\nsource IP address sending the knocks will be permanently authenticated until it\
\nis removed from the iptables whitelist via separate, independent iptables rule\
\nmanipulation.\
\n   s) strict knock rules are conventional port knock rules where every port-\
\nprotocol knock must arrive in sequence with none missed.  NO OTHER PORT-PROTOCOL\
\nCOMBINATION ATTEMPTS MAY OCCUR DURING THE STRICT KNOCK-AUTHENTICATION PROCESS,\
\nbut youll be allowed to specify non-unique port-protocols, even consecutively.\
\nSeven seconds maximum is allowed between each knock.  After the knock sequence\
\nis completed successfully, the knocking computer will be given only 17 seconds\
\nin which to establish valid communication, and the knock sequence must be\
\nrepeated for each future session.   Press a key...";read -n1 -s )
            done
            printf "\n\nSetting up port knocking.\
\nTip: For added obfuscation against packet-sniffing eavesdroppers, you can\
\nspecify any knock packet or packets to be disguised as an established connection\
\npacket rather than a knocking packet by replacing \"--syn\" with \"--tcp-flags ACK\
\nACK\".  Ideally, it would carry data you would craft that appears to be part of\
\nestablished-connection communication to help disguise it as a normal packet.\
\nYou could go so far as to require that specific byte string to be required in\
\nthat knock, but to generate such specialty knock packets will for sure require\
\nthe knocking client to use a packet-crafting tool.  Exactly for that scenario,\
\nthese rules will configure to reply to such a knock packet with a TCP RST packet\
\nto make the obfuscation less obvious.  (If you intend for your server to be\
\ninvisible, however, you probably don't want to require such a packet as the\
\nfirst knock because not only can and will your system be visible, its first\
\nknock port will also be giving itself away.  ACK knocks as described will only\
\nproduce server replies if the knocking computer is correctly knocking through\
\nthe sequence up to that point in the sequence.)  If you want to require ACK\
\nknocks but you don't want this server to reply to them at all, modify the iptables\
\nruleset accordingly after installation.\
\nTo specify the data you might require in a knock packet, include the following\
\nin the protocol:\
\n\n-m string --algo=bm --string \"bm-encrypted normal-looking data\"\n\n"

#write rules to iptables rule set
            if [[ $REPLY == "l" ]];then
                 if_first_knock_is_ACK_message=""
                 get_operator_knock_choices unique
                 for (( j=1;j<i;j++ )); do
                      printf "$iptablespath -wA poofitee_knockstage$j${knockproto[$j]}\n"
                 done
printf "\n\nYour current iptables ruleset is about to be changed to reflect your knock\
\nentries just made.  The following changes are about to be made:\
\n\n  -- All INPUT chain rules will be removed that contain the string\
\n        \"poofitee_knock\" in their comment\
\n\n  -- INPUT chain will receive all new knock rules that belong there, being\
\n        placed adjacent and prior to current non-knock rules referencing the\
\n        respective interface\
\n\n  -- Poofitee chains knock_check, knock_new_knock, knock_portcustomexit,\
\n        and others will be created new\
\n\n  -- Poofitee chains knockerreap, knockersort, knockers, and all knockstages\
\n        will be de-referenced and abandoned without flushing.  They are only\
\n        used in the strict knock ruleset\
\n\nOnly continue if you are sure about making the changes.  To keep your current\
\niptables rules as they are, quit now by pressing ctl-c.  Otherwise, make the\
\nqueued changes by pressing any other key....\n";read -rsn 1;read -rst 0.001 -n3
                 j=$(($($iptablespath -wnL INPUT --line-number|$awkpath 'END {print $1}')))
                 for ((;j>0;j--)); do
                      [[ $($iptablespath -wnL INPUT $j 2>/dev/null) =~ poofitee_knock ]] && ([[ $($iptablespath -wD INPUT $j 2>/dev/null;echo "$?") == "0" ]] && echo "Removed INPUT chain rule $j assuming it was from the previous, obsolete poofitee knock ruleset" || printf "Failed 5")
                 done
# start making rules here
                 [[ $($iptablespath -wN poofitee_knock_check 2>/dev/null;echo "$?") == "0" ]] || $iptablespath -wF poofitee_knock_check 2>/dev/null
                 [[ $($iptablespath -wN poofitee_knock_new_knock 2>/dev/null;echo "$?") == "0" ]] || $iptablespath -wF poofitee_knock_new_knock 2>/dev/null
                 [[ $($iptablespath -wN poofitee_knock_authorize 2>/dev/null;echo "$?") == "0" ]] || $iptablespath -wF poofitee_knock_authorize 2>/dev/null
                 [[ $($iptablespath -wN poofitee_knock_seniorize 2>/dev/null;echo "$?") == "0" ]] || $iptablespath -wF poofitee_knock_seniorize 2>/dev/null
                 [[ $($iptablespath -wN poofitee_knock_juniorize 2>/dev/null;echo "$?") == "0" ]] || $iptablespath -wF poofitee_knock_juniorize 2>/dev/null
                 [[ $($iptablespath -wN poofitee_knock_sophomorize 2>/dev/null;echo "$?") == "0" ]] || $iptablespath -wF poofitee_knock_sophomorize 2>/dev/null
                 [[ $($iptablespath -wN poofitee_knock_customexit 2>/dev/null;echo "$?") == "0" ]] || $iptablespath -wF poofitee_knock_customexit 2>/dev/null
                 j=0
                 while ! [[ -z "${knockproto[$(($j + 1))]}" ]];do
                      j=$(( $j + 1 ))
                      [[ $($iptablespath -wA poofitee_knock_check ${knockproto[$j]} -m recent --name poofitee_knock_port$j --rcheck -j RETURN;echo "$?") == "0" ]] || printf "Failed 1"
                 done
                 j=0
                 while ! [[ -z "${knockproto[$(($j + 1))]}" ]];do
                      j=$(( $j + 1 ))
                      [[ $($iptablespath -wA poofitee_knock_check ${knockproto[$j]} -m recent --name poofitee_knock_port$j --set -j poofitee_knock_new_knock;echo "$?") == "0" ]] || printf "Failed 2"
                      [[ $($iptablespath -wA poofitee_knock_customexit ${knockproto[$j]} ${testtarget[$j]};echo "$?") == "0" ]] || printf "Failed 3"
                 done
                 [[ $($iptablespath -wA poofitee_knock_new_knock -m recent --name poofitee_knock_senior --rcheck --seconds $(( $j * 12 )) --reap -j poofitee_knock_authorize 2>/dev/null;echo "$?") == "0" ]] || printf "Failed 7"
                 [[ $($iptablespath -wA poofitee_knock_new_knock -m recent --name poofitee_knock_junior --rcheck --seconds $(( $j * 12 )) --reap -j poofitee_knock_seniorize 2>/dev/null;echo "$?") == "0" ]] || printf "Failed 8"
                 [[ $($iptablespath -wA poofitee_knock_new_knock -m recent --name poofitee_knock_sophomore --rcheck --seconds $(( $j * 12 )) --reap -j poofitee_knock_juniorize 2>/dev/null;echo "$?") == "0" ]] || printf "Failed 9"
                 [[ $($iptablespath -wA poofitee_knock_new_knock -m recent --name poofitee_knock_freshman --rcheck --seconds $(( $j * 12 )) --reap -j poofitee_knock_sophomorize 2>/dev/null;echo "$?") == "0" ]] || printf "Failed 10"
                 [[ $($iptablespath -wA poofitee_knock_new_knock -m recent --name poofitee_knock_freshman --set -j LOG --log-prefix "poofitee knock freshman " -m comment --comment "poofitee_knock:This will schedule its blacklisting for couple mins from now" 2>/dev/null;echo "$?") == "0" ]] || printf "Failed 11"
                 [[ $($iptablespath -wA poofitee_knock_new_knock -j poofitee_knock_customexit 2>/dev/null;echo "$?") == "0" ]] || printf "Failed 12"
                 [[ $($iptablespath -wA poofitee_knock_authorize -m recent --name poofitee_knock_authorized --set -j LOG --log-prefix "poofitee knock authorized " 2>/dev/null;echo "$?") == "0" ]] || printf "Failed 13"
                 [[ $($iptablespath -wA poofitee_knock_authorize -j poofitee_knock_customexit 2>/dev/null;echo "$?") == "0" ]] || printf "Failed 14"
                 [[ $($iptablespath -wA poofitee_knock_seniorize -m recent --name poofitee_knock_senior --set -j LOG --log-prefix "poofitee knock senior " -m comment --comment "poofitee_knock" 2>/dev/null;echo "$?") == "0" ]] || printf "Failed 15"
                 [[ $($iptablespath -wA poofitee_knock_seniorize -j poofitee_knock_customexit 2>/dev/null;echo "$?") == "0" ]] || printf "Failed 16"
                 [[ $($iptablespath -wA poofitee_knock_juniorize -m recent --name poofitee_knock_junior --set -j LOG --log-prefix "poofitee knock junior " -m comment --comment "poofitee_knock" 2>/dev/null;echo "$?") == "0" ]] || printf "Failed 17"
                 [[ $($iptablespath -wA poofitee_knock_juniorize -j poofitee_knock_customexit 2>/dev/null;echo "$?") == "0" ]] || printf "Failed 18"
                 [[ $($iptablespath -wA poofitee_knock_sophomorize -m recent --name poofitee_knock_sophomore --set -j LOG --log-prefix "poofitee knock sophomore " -m comment --comment "poofitee_knock" 2>/dev/null;echo "$?") == "0" ]] || printf "Failed 19"
                 [[ $($iptablespath -wA poofitee_knock_sophomorize -j poofitee_knock_customexit 2>/dev/null;echo "$?") == "0" ]] || printf "Failed 20"
                 find_first_reference_to_internal_interface
                 if ! [[ -z "$internal_net_interface" ]];then
                      [[ $($iptablespath -wI INPUT $linenumber_for_inserting_before -i $(echo "$internal_net_interface"|$xargspath|$awkpath '{print $1}') -j poofitee_knock_check 2>/dev/null;echo "$?") == "0" ]] && linenumber_for_inserting_before=$(($linenumber_for_inserting_before + 1)) || printf "Failed 22"
                 fi
                 if [[ -z "$linenumber_for_inserting_before" ]];then
                      linenumber_for_inserting_before="1" #even though we may never use this var again
                      line_number_for_authorized_rule="1"
                 fi
                 [[ $($iptablespath -wI INPUT $line_number_for_authorized_rule -m recent --name poofitee_authorized --rcheck --mask 255.255.255.255 -m comment --comment "poofitee_knock loose rule" -j ACCEPT 2>/dev/null;echo "$?") == "0" ]] && linenumber_for_inserting_before=$(( $linenumber_for_inserting_before + 1 )) || printf "Failed 19"
                 back_up_iptables_ruleset new && \
                      printf "Note that the file name is different than the one saved before" || \
                      printf "Your new iptables ruleset did NOT get backed up correctly.  You should\
\ntroubleshoot the problem, correct it, and start this install over again.\n"
            else
                 echo "Setting strict rules here"
                 if_first_knock_is_ACK_message="If you intend for your server to be invisible to the world, at least beyond the\
\nnext router, the best way to disguise a TCP ACK packet on the first knock is for\
\nthis server not to reply with the otherwise suggested tcp-reset rejection\
\nresponse, mostly because your system will forever be visible on that port to the\
\nworld, but also because its first port knock will be giving itself away.  Or you\
\nmay turn off the disguising tcp-reset reject reply for this knock only.  Press\
\n\'r\' to re-enter entire knock, or \'k\' to keep the reject response anyway (not\
\nadvised for minimum visibility). Any other key will turn off the reject response\
\nto this knock: (r/k/...)"
                 get_operator_knock_choices
                 for (( j=1;j<i;j++ )); do
                      printf "$iptablespath -wA poofitee_knockstage$j${knockproto[$j]}\n"
                 done
                 printf "\n\nYour current iptables ruleset is about to be changed to reflect your knock\
\nentries just made.  The following changes are about to be made:\
\n\n  -- All INPUT chain rules will be removed that contain the string\
\n        \"poofitee_knock\" in their comment\
\n\n  -- INPUT chain will receive all new knock rules that belong there, being\
\n        placed adjacent and prior to current non-knock rules referencing the\
\n        respective interface\
\n\n  -- Poofitee chains knockerreap, knockersort, knockers, and all knockstages\
\n        will be created new\
\n\n  -- Poofitee chains knock_check, knock_new_knock, knock_portcustomexit,\
\n        and others will be de-referenced and abandoned.  They are only\
\n        used in the loose knock ruleset\
\n\nOnly continue if you are sure about making the changes.  To keep your current\
\niptables rules as they are, quit now by pressing ctl-c.  Otherwise, make the\
\nqueued changes by pressing any other key....\n";read -rsn 1;read -rst 0.001 -n3
                 $iptablespath -wN poofitee_knockerreap 2>/dev/null # ;echo "$?") == "0" ]] || printf "Failed 1"
                 [[ $($iptablespath -wF poofitee_knockerreap 2>/dev/null;echo "$?") == "0" ]] || (printf "Failed to flush poofitee_knockerreap chain rules";break)
                 $iptablespath -wN poofitee_knockersort 2>/dev/null # ;echo "$?") == "0" ]] || printf "Failed 3"
                 [[ $($iptablespath -wF poofitee_knockersort 2>/dev/null;echo "$?") == "0" ]] || (printf "Failed to flush poofitee_knockersort chain rules";break)
                 j=$(($($iptablespath -wnL INPUT --line-number|$awkpath 'END {print $1}')))
                 for ((;j>0;j--)); do
                      [[ "$($iptablespath -wnL INPUT $j 2>/dev/null)" =~ poofitee_knock ]] && ([[ $($iptablespath -wD INPUT $j 2>/dev/null;echo "$?") == "0" ]] && echo "Removed INPUT chain rule $j assuming it was from the previous, obsolete poofitee knock ruleset"|| printf "Failed 5")
                 done
                 j=16  # here is the limit on number of knocks we can handle, just won't clear old ones above this
                 while [[ -z "${knockport[$j]}" ]];do
                      $iptablespath -wF poofitee_knockstage$j 2>/dev/null
                      j=$(( $j-1 ))
                 done
                 j=0
                 while ! [[ -z "${knockport[$(($j + 1))]}" ]];do
                      j=$(( $j+1 ))
                      $iptablespath -wN poofitee_knockstage$j 2>/dev/null # ;echo "$?") == "0" ]] || printf "Failed 6"
                      [[ $($iptablespath -wF poofitee_knockstage$j 2>/dev/null;echo "$?") == "0" ]] || printf "Failed 7"
                      if ! [[ "$j" == "1" ]];then
                           [[ $($iptablespath -wA poofitee_knockersort ${knockproto[$j]} -m recent --name poofitee_knockstage$j --rcheck --seconds 12 -m comment --comment "knock to stage $j successful" -j poofitee_knockstage$j  2>/dev/null;echo "$?") == "0" ]] || printf "Failed 7.5"
                      fi
                      [[ $($iptablespath -wI poofitee_knockstage$j -j poofitee_knockerreap;echo "$?") == "0" ]] || printf "Failed 9"
                      [[ $($iptablespath -wI poofitee_knockstage$j 2 -m recent --name poofitee_knockstage$(( $j + 1 )) --set -j LOG --log-prefix "knocked: Stage$j " -m comment --comment "Entry in log makes blacklisting get delayed until after knocking time window expires";echo "$?") == "0" ]] || printf "Failed 10"
#Here we put the right DROP or REJECT target in the third rule under this chain
                      [[ $($iptablespath -wA poofitee_knockstage$j ${testtarget[$j]} ;echo "$?") == "0" ]] || printf "Failed 11"
                 done
                 i=$(( $j + 1 ))
                 while [[ $($iptablespath -wF poofitee_knockstage$i 2>/dev/null;echo "$?") == "0" ]];do
                      i=$(( $i+1 ))
                 done
# start making rules here
                 $iptablespath -wN poofitee_knockers 2>/dev/null # ;echo "$?") == "0" ]] || printf "Failed"
                 [[ $($iptablespath -wF poofitee_knockers 2>/dev/null;echo "$?") == "0" ]] || printf "Failed 12"
# for persistent whitelisting only
#                 [[ $($iptablespath -wR poofitee_knockstage$j 2 -j LOG --log-prefix "whitelist " -m comment --comment "Entry in log to delay blacklisting until knocking time window expires" 2>/dev/null;echo "$?") == "0" ]] || printf "Failed"
                 [[ $($iptablespath -wR poofitee_knockstage$j 2 -m recent --name poofitee_authorized --set -j LOG --log-prefix "knock full success whitelist" -m comment --comment "allows 1 time-limited attempt to establish a dialog" 2>/dev/null;echo "$?") == "0" ]] || printf "Failed 12.5"
                 inchainoffset=0
                 find_first_reference_to_internal_interface
                 if ! [[ -z "$internal_net_interface" ]];then
                      [[ $($iptablespath -wI INPUT $linenumber_for_inserting_before -i $(echo "$internal_net_interface"|$xargspath|$awkpath '{print $1}') -m recent --name poofitee_knocker --seconds 60 --rcheck -j poofitee_knockerstest -m comment --comment "poofitee_knock" 2>/dev/null;echo "$?") == "0" ]] && linenumber_for_inserting_before=$(( $linenumber_for_inserting_before + 1 )) || printf "Failed 15"
                      [[ $($iptablespath -wI INPUT $linenumber_for_inserting_before -i $(echo "$internal_net_interface"|$xargspath|$awkpath '{print $1}') ${knockproto[1]} -m recent --set --name poofitee_knocker -j poofitee_knockstage1 -m comment --comment "poofitee_knock, 1st port" 2>/dev/null;echo "$?") == "0" ]] && linenumber_for_inserting_before=$(( $linenumber_for_inserting_before + 1 )) || printf "Failed 16"
#                      [[ $($iptablespath -wI INPUT $linenumber_for_inserting_before -i $(echo "$internal_net_interface"|$xargspath|$awkpath '{print $1}') -j ACCEPT -m comment --comment "allow all from private side" 2>/dev/null;echo "$?") == "0" ]] && linenumber_for_inserting_before=$(( $linenumber_for_inserting_before + 1 )) || printf "Failed 17"
                      $iptablespath -wA poofitee_knockerstest -j poofitee_knockersort
                      $iptablespath -wA poofitee_knockerstest -j LOG --log-prefix "poofitee_knockertest fail "
                      $iptablespath -wA poofitee_knockerstest -m recent --rcheck --seconds 200 --reap --name poofitee_knocker --mask 255.255.255.255 --rsource
                      $iptablespath -wA poofitee_knockerstest -m recent --remove --name poofitee_knocker --mask 255.255.255.255 --rsource
                      $iptablespath -wA poofitee_knockerstest -j poofitee_knockerreap
                      $iptablespath -wA poofitee_knockerstest -j DROP
                 fi
                 if [[ -z "$linenumber_for_inserting_before" ]];then
                      linenumber_for_inserting_before="1"
                      line_number_for_authorized_rule="1"
                 fi
                 [[ $($iptablespath -wI INPUT $line_number_for_authorized_rule -m recent --remove --name poofitee_authorized --mask 255.255.255.255 --rsource  -m conntrack --ctstate NEW -m comment --comment "poofitee_knock 1-packet pass: 1 chance to establish or then knock higher" -j ACCEPT 2>/dev/null;echo "$?") == "0" ]] && linenumber_for_inserting_before=$(( $linenumber_for_inserting_before + 1 )) || printf "Failed 19"
                 [[ $($iptablespath -wI INPUT $linenumber_for_inserting_before -i $external_net_interface -m recent --name poofitee_knocker --seconds 200 --rcheck  -m conntrack --ctstate NEW -j poofitee_knockers -m comment --comment "poofitee_knock" 2>/dev/null;echo "$?") == "0" ]] && linenumber_for_inserting_before=$(( $linenumber_for_inserting_before + 1 )) || printf "Failed 18"
                 [[ $($iptablespath -wI INPUT $linenumber_for_inserting_before -i $external_net_interface -m conntrack --ctstate NEW ${knockproto[1]} -m recent --set --name poofitee_knocker -j poofitee_knockstage1 -m comment --comment "poofitee_knock, 1st port" 2>/dev/null;echo "$?") == "0" ]] || printf "Failed 20"
                 [[ $($iptablespath -wA poofitee_knockers -m conntrack ! --ctstate NEW -j poofitee_knockerreap -m comment --comment "for port knock capability" 2>/dev/null;echo "$?") == "0" ]] || printf "Failed 21"
                 [[ $($iptablespath -wA poofitee_knockers -m conntrack --ctstate NEW -j poofitee_knockersort -m comment --comment "for port knock capability" 2>/dev/null;echo "$?") == "0" ]] || printf "Failed 22"
                 [[ $($iptablespath -wA poofitee_knockers -j LOG --log-prefix "pktfail:knock|late|ctstate " 2>/dev/null;echo "$?") == "0" ]] || printf "Failed 23"
                 [[ $($iptablespath -wA poofitee_knockers -m recent --name poofitee_knocker --rcheck --reap --seconds 200 2>/dev/null;echo "$?") == "0" ]] || printf "Failed 24"
                 [[ $($iptablespath -wA poofitee_knockers -m recent --name poofitee_knocker --remove 2>/dev/null;echo "$?") == "0" ]] || printf "Failed 25"
                 [[ $($iptablespath -wA poofitee_knockers -j poofitee_knockerreap 2>/dev/null;echo "$?") == "0" ]] || printf "Failed 26"
                 [[ $($iptablespath -wA poofitee_knockers -j DROP 2>/dev/null;echo "$?") == "0" ]] || printf "Failed 27"

                 [[ $($iptablespath -wA poofitee_knockerreap -m recent --name poofitee_knocker --rcheck --reap --seconds 200 2>/dev/null;echo "$?") == "0" ]] || printf "Failed 28"
                 for ((j=1;j<=i;j++));do
                      [[ $($iptablespath -wA poofitee_knockerreap -m recent --name poofitee_knockstage$j --set  2>/dev/null;echo "$?") == "0" ]] || printf "Failed 29"
                 done
                 for ((j=1;j<=i;j++));do
                      [[ $($iptablespath -wA poofitee_knockerreap -m recent --name poofitee_knockstage$j --rcheck  --reap --seconds 12 2>/dev/null;echo "$?") == "0" ]] || printf "Failed 30"
                 done
                 for ((j=1;j<=i;j++));do
                      [[ $($iptablespath -wA poofitee_knockerreap -m recent --name poofitee_knockstage$j --remove 2>/dev/null;echo "$?") == "0" ]] || printf "Failed 31"
                 done

            fi
printf "\nServer-side port knocking installed.\n"
}
       install_buildiptablessh () {
# TODO: CURRENTLY UNDERWAY: converting from the following shell script backup ruleset to iptables-type restore. 
if ! [[ -z "$internal_net_interface" ]] && [[ "$($greppath -c ^net.ipv4.ip_forward=1 </etc/sysctl.conf)" == "0" ]];then
     [[ "$($iptablespath -wnvL POSTROUTING -t nat)" =~ MASQUERADE.*$external_net_interface ]] && iptables_masquerading=true || iptables_masquerading=false
     cat <<EOF
This server is capable of being a firewall for an internal network, but you
haven't enabled the forwarding feature needed in Linux, at least persisently.
If you'd like, that $( [[ $iptables_masquerading == false ]] && printf "and the iptables MASQUERADE ")can be easily enough done for
you right now, but IP address, routing tables, and DNAT in iptables POSTROUTING
nat table configurations are left completely to you at this stage of POOFITEE
development.  Would you like to enable IP forwarding persistently and have
iptables masquerade your internal network so it has Internet access? y/n:
EOF
     read -rn1;read -rsn3 -t 0.001 discard
     if [[ $REPLY =~ [Yy] ]];then
          echo 1 > /proc/sys/net/ipv4/ip_forward
          $sedpath -i 's/^#*net.ipv4.ip_forward=.*/net.ipv4.ip_forward=1/g' /etc/sysctl.conf
          [[ "$($greppath -c ^net.ipv4.ip_forward=1 </etc/sysctl.conf)" == "0" ]] && echo "net.ipv4.ip_forward=1" >> /etc/sysctl.conf
          [[ $iptables_masquerading == false ]] && ([[ "$($iptablespath -wt nat -I POSTROUTING 1  -o $external_net_interface  -p all -j MASQUERADE -m comment --comment "by installer request during poofitee_firewall installation";echo $?)" == "0" ]] || printf "\n\nUnable to make the change in iptables")
     fi
fi
            (cat <<BUILDIPTABLES.SH_END
echo 1 > /proc/sys/net/ipv4/ip_forward
$iptablespath -wF
$iptablespath -wX
$iptablespath -wt nat -F
$iptablespath -wt nat -X
$iptablespath -wt mangle -F
$iptablespath -wt mangle -X
$iptablespath -wt nat -P PREROUTING ACCEPT
$iptablespath -wt nat -P INPUT ACCEPT
$iptablespath -wt nat -P OUTPUT ACCEPT
$iptablespath -wt nat -P POSTROUTING ACCEPT
$iptablespath -wt nat -I POSTROUTING 1  -o $external_net_interface  -p all -j MASQUERADE -m comment --comment "poofitee_firewall"
$iptablespath -wP INPUT ACCEPT
$iptablespath -wP FORWARD ACCEPT
$iptablespath -wP OUTPUT ACCEPT
$iptablespath -wN poofitee_firewall_d_privateIPs
$iptablespath -wN poofitee_firewall_d_static_trusted
$iptablespath -wN poofitee_firewall_d_whitelist
$iptablespath -wN poofitee_firewall_s_blacklist
$iptablespath -wN poofitee_firewall_s_privateIPs
$iptablespath -wN poofitee_firewall_s_static_trusted
$iptablespath -wN poofitee_firewall_s_whitelist
$iptablespath -wA INPUT -i $external_net_interface -p all -j s_privateIPs -m comment --comment "poofitee_firewall"
$iptablespath -wA INPUT -i $internal_net_interface -p all -j ACCEPT -m comment --comment "poofitee_firewall"
$iptablespath -wA INPUT -p all -j poofitee_firewall_s_static_trusted
$iptablespath -wA INPUT -p all -j poofitee_firewall_s_whitelist
$iptablespath -wA INPUT -p all -j poofitee_firewall_s_blacklist
$iptablespath -wA INPUT -p all -j LOG --log-level 4 -m comment --comment "poofitee_firewall"
$iptablespath -wA INPUT -p all -j DROP -m comment --comment "poofitee_firewall"
$iptablespath -wI FORWARD 1 -p all -j DROP -m comment --comment "poofitee_firewall"
$iptablespath -wI FORWARD 1 -p all -j LOG --log-level 4 -m comment --comment "poofitee_firewall"
$iptablespath -wI FORWARD 1 -p all -j poofitee_firewall_s_blacklist
$iptablespath -wI FORWARD 1 -o $external_net_interface -p all -j poofitee_firewall_d_privateIPs
$iptablespath -wI FORWARD 1 -i $external_net_interface -p all -j poofitee_firewall_s_privateIPs
$iptablespath -wI FORWARD 1 -p all -j poofitee_firewall_d_blacklist
$iptablespath -wI FORWARD 1 -p all -j poofitee_firewall_d_whitelist
$iptablespath -wI FORWARD 1 -p all -j poofitee_firewall_s_whitelist
$iptablespath -wI FORWARD 1 -p all -j poofitee_firewall_s_static_trusted
$iptablespath -wI FORWARD 1 -p all -j poofitee_firewall_d_static_trusted
$iptablespath -wI FORWARD 1 -o $external_net_interface -p all -j ACCEPT -m comment --comment "poofitee_firewall"
$iptablespath -wI OUTPUT 1 -p all -j poofitee_firewall_d_blacklist
$iptablespath -wI OUTPUT 1 -p all -j poofitee_firewall_d_blacklist
$iptablespath -wI poofitee_firewall_d_privateIPs 1 -d 10.0.0.0/8 -p all -m comment --comment "poofitee_firewall_private IPs" -j DROP
$iptablespath -wI poofitee_firewall_d_privateIPs 1 -d 172.16.0.0/12 -p all -m comment --comment "poofitee_firewall_private IPs" -j DROP
$iptablespath -wI poofitee_firewall_d_privateIPs 1 -d 192.168.0.0/16 -p all -m comment --comment "poofitee_firewall_private IPs" -j DROP
$iptablespath -wI poofitee_firewall_d_static_trusted 1 -d 199.102.46.70 -p all -m comment --comment "poofitee_firewall_local time server hosted by Monticello" -j ACCEPT
$iptablespath -wI poofitee_firewall_s_privateIPs 1 -s 192.168.0.0/16 -p all -m comment --comment "poofitee_firewall_private IPs" -j DROP
$iptablespath -wI poofitee_firewall_s_privateIPs 1 -s 172.16.0.0/12 -p all -m comment --comment "poofitee_firewall_private IPs" -j DROP
$iptablespath -wI poofitee_firewall_s_privateIPs 1 -s 10.0.0.0/8  -p all -m comment --comment "poofitee_firewall_private IPs" -j DROP
$iptablespath -wI poofitee_firewall_s_static_trusted 1 -s 91.189.88.0/21 -p all -m comment --comment "poofitee_firewall Canonical" -j ACCEPT
$iptablespath -wI poofitee_firewall_s_static_trusted 1 -i lo -p all -m comment --comment "poofitee_firewall we really have to trust localhost at this level" -j ACCEPT
$iptablespath -wI poofitee_firewall_s_static_trusted 1 -m conntrack --ctstate RELATED,ESTABLISHED -p all -m comment --comment "poofitee_firewall existing dialogs traffic presumed trusted" -j ACCEPT
BUILDIPTABLES.SH_END
) > "$directoryforscripts/preparedness/buildiptables.sh"
          chmod 700 "$directoryforscripts/preparedness/buildiptables.sh"
          echo "$directoryforscripts/preparedness/buildiptables.sh set up..."
       }
       install_cronentries () {
#  Only need to confirm if there are entries in crontab
date_for_cronentries_backup="poofitee_installer_$(date)"
crontab -l > "$directoryforscripts/cronentries.$date_for_cronentries_backup"
if [[ $(($(echo "$?"))) -eq 0 ]] && [[ $(($(wc -l < "$directoryforscripts/cronentries.$date_for_cronentries_backup"))) -gt 0 ]];then
     ! [[ "$(eval $crontabpath -l|$greppath -E -v ^#|$greppath -v ^[[:space:]]*$|$wcpath -l)" == "0" ]] && \
     (printf "$(eval $crontabpath -l|$greppath -E -v ^#|$greppath -v ^[[:space:]]*$|$wcpath -l) entries in crontab:\n\n$(eval "$crontabpath -l|$greppath -E -v ^#|$greppath -v ^[[:space:]]*$")\
\nConfirm you understand that your crontab shell is now getting changed which\
\nmight affect the above entries if they send values out, contain quotes, etc.\n"
      read -n1 -s -p "You will need to verify proper operation of current entries after this: ")
(cat << CRONTAB_ENTRIES_END
$($crontabpath -l)\
# line below is from poofitee_firewall
@reboot $nicepath -n15 $tailpath -F -n 0 /var/log/kern.log|$greppath --line-buffered ' SRC='|$stdbufpath -o0 $greppath -v 'SRC=10\.'|$stdbufpath -o0 $greppath -v 'SRC=0\.0\.0\.0'|$stdbufpath -o0 $greppath -v 'SRC=127.0\.0\.1'|$stdbufpath -o0 $greppath -v 'SRC=192\.168\.'|$stdbufpath -o0 $awkpath '{for (i=6;i<=NF;i++) {if (\$i ~ "^SRC=") {{gsub("SRC=","",\$i); printf \$i" \""} printf "kern.log "\$1" "\$2" "\$3; for (j=i;j<=NF;j++) {if (\$j ~ "^PROTO=" || \$j ~ "^SPT=" || \$j ~ "^DPT") {printf " "\$j}} printf "\" \""; for (j=6;j<i;j++) {printf " "\$j} printf "\""}}}'|$xargspath -l1 "$directoryforscripts/process_source_ip.sh"  >/dev/null 2>&1
CRONTAB_ENTRIES_END
) |$crontabpath -
     [[ "$(eval "$crontabpath -l|$greppath -c \"SHELL=\"")" == "0" ]] && \
       printf "SHELL=/bin/bash\n$($crontabpath -l)"|$crontabpath - || \
       eval "$crontabpath -l|$sedpath \"/SHELL=/c\SHELL=/bin/bash\"|$crontabpath -"
     printf "\ncrontab set up...Original can be found in $directoryforscripts/cronentries"
else
     printf "\n\nYour cron file isn't saving to $directoryforscripts/cronentries, aborting...\n"
fi
          }
       conf_postfix () {
! [[ -z postfix_already_conf ]] && return
# See https://www.linode.com/docs/email/postfix/postfix-smtp-debian7
while true;do
     clear;printf "$( [[ -z $sendmail_works ]] && echo "Three" || echo "Two more" ) emailing functions need email addresses.  Provide at least one email\
\naddress now.  The address[es] asked for now is/are the one or more that will\
\nreceive the various notifications sent out by this system.  Commonly, this would\
\nbe at least two addresses - one for a text message to a cell phone, the other an\
\nemail account from which you'll read the FULL content of the notification, since\
\ncell phone carriers often limit the length of email-to-texting conversion,\
\ncutting short the longer texts."
     printf "\nAddress[es] where to send notifications to:\n"
     get_sendto_emailadds
done
if [[ -z $sendmail_works ]];then
              printf "\nNow, a single email address with its password is needed for an outgoing email\
\nserver somewhere to authenticate the outgoing email traffic (it's come to this\
\nbecause of spammers).  Enter now the email account name to use for an outgoing\
\nemail server based on its ability to accept sign-on through this scripting\
\nyou're installing.  Preferrably not too strict accepting sign-on because this\
\nscript uses the mid-tier security of standard smtp protocol (your email\
\ncredentials, including password, are stored in this scripting and sent encrypted\
\nbut via standard smtp protocol) rather than upper-tier security (\"OAuth 2.0\" -\
\ncredentials entered on a web page that only a real human can reliably determine\
\nwhere on the screen to enter the credentials today, which may be different from\
\nyesterday.  It also includes a sort of dynamic security key exchange not\
\navailable via standard smtp protocol).  NOTE - this email account may be the\
\nsame or different from the one that the notices get sent to.  We can test and\
\ncompare suitability repeatedly, so you may select from all your accounts which\
\none this scripting is most able to sign into (use up/down arrow keys, or enter a\
\nnew name entirely).  SUGGESTION: If reading this has made you suspicious to give\
\nyour real email password to this script ( hopefully so! ), create a NEW account\
\nwith a provider such as gmail that will allow logins from \"less secure apps\" on\
\na per-account basis (gmail does), set it up to allow such logins.  (You'll use\
\nthat NEW account for this script's outgoing email authentication needs.)  Then\
\nresume here and enter that account name and password.  That same account could\
\nalso be dedicated for this scripting to read commands emailed from you for it to\
\nbe remote controlled:/n"

(cat <<EOF1
#!/bin/bash
lineshere="\$($greppath -E --line-number "^:$" < \$0)"
(cat << EOF
#!/bin/bash
$headpath -n "\${lineshere%::*}" \$0 > \$0.bak
mv \$0.bak \$0
chmod 777 \$0
EOF
) > cleanup.sh
chmod 777 cleanup.sh
./cleanup.sh
# read -s -n 1 -p "press a key before while..."
while getopts "t:" opt; do
# read -s -n 1 -p "press a key in while before case..."
  case "\$opt" in
      t) timeout=\$OPTARG;shift \$((OPTIND-1)) ;;
  esac
#  read -s -n 1 -p "press a key in while after case..."
done
# read -s -n 1 -p "press a key after both while and case..."

start_watchdog(){
  timeout="\$1"
  (( i = timeout ))
  while (( i > 0 ))
  do
      kill -0 \$\$ || exit 0
      sleep 1
      (( i -= 1 ))
  done

  # echo "killing process after timeout of \$timeout seconds"
  kill \$\$
}

start_watchdog "\$timeout" 2>/dev/null &
echo "\$@" >> "\$0"
:

EOF1
) > "timeouttry.sh"
chmod 700 "timeouttry.sh"
while true;do  #this loop allows user to change the email account for outbound server & builds connect.txt file
     while true; do #this loop forces an address to be chosen from the bunch, then goes through all connections found for it
          get_1_addr_from_bunch $toemailadds
          outemailadd="emailadd";outemailacct="$emailacct";outemaildomain="$emaildomain";outtopdomain="$topdomain";outemailprovider="$emailprovider";outemailpw="$emailpw"
          printf "determining best option for outgoing email server login.  You should be doing\
\nthis step from the Internet location of final operation if you have/want your\
\nlocal ISP-provided email account considered for your outgoing email server...\n"
          [[ -f "$directoryforscripts/$outemailprovider.outconnects.txt" ]] \
             && rm "$directoryforscripts/$outemailprovider.outconnects.txt" 2>/dev/null
          printf  "\rYou selected address $outemailadd \033[K\n"
          while ! [[ "$(dig +short myip.opendns.com @resolver1.opendns.com)" =~ ^((1?[0-9]?[0-9]|2[0-4][0-9]|25[0-5])\.){3}(1?[0-9]?[0-9]|2[0-4][0-9]|25[0-5])$ ]];do
                printf "\r\033[KNo internet connection found with full DNS.  Press a key when corrected...";read -rsn 1;read -rst 0.001 -n3
          done
          for MAIL_PROT in smtp mail;do
               for port in 587 25 2587 26 2525 25025 2526 3325 465 995 110 993 143;do
                    printf "\rChecking $MAIL_PROT.$outemailprovider:$port\033[K";
                    (./timeout.sh -t 2 "exec 5>&-;exec 5<>/dev/tcp/$MAIL_PROT.$outemailprovider/$port;read -u 5 HELO;! [[ -z \$HELO ]] && printf \"$MAIL_PROT:$port\" >> \"$directoryforscripts/$outemailprovider.outconnects.txt\";printf \"quit\" >&5;read -t 2 -u 5 QUIT;exec 5>&-")
               done  2> /dev/null
          done
          if [[ -f "$directoryforscripts/$outemailprovider.outconnects.txt" ]];then
               printf "\rThe possibilities are\033[K\n$(<"$directoryforscripts/$outemailprovider.outconnects.txt")"
               break
          else
               printf "\r\033[K\033[1ASelected email provider doesn't allow logins.  Enter a different account...\n"
          fi
     done
     while read -u 3 -r line;do #? this while loop iterates once for each port that accepted a smtp connection for outgoing email
          chmod 644 /etc/postfix/main.cf
          [[ "$($greppath -c ^myhostname </etc/postfix/main.cf)" == "0" ]] \
              && printf "myhostname = ""$(hostname)" >> /etc/postfix/main.cf \
              || $sedpath -i 's/^myhostname.*/myhostname = '"$(hostname)"'/g' /etc/postfix/main.cf
          [[ "$($greppath -c ^relayhost </etc/postfix/main.cf)" == "0" ]] \
              && printf "relayhost = ["${line%:*}"."$outemailprovider"]:"${line#*:} >> /etc/postfix/main.cf \
              || $sedpath -i 's/^relayhost.*/relayhost = ['"${line%:*}.$outemailprovider]:${line#*:}"'/g' /etc/postfix/main.cf
          [[ "$($greppath -c ^mech_list: cram-md5 </etc/postfix/sasl/smtpd.conf)" == "0" ]] \
              && printf "mech_list: cram-md5" >> /etc/postfix/sasl/smtpd.conf
          [[ "$($greppath -c ^smtp_sasl_auth_enable </etc/postfix/main.cf)" == "0" ]] \
              && printf "smtp_sasl_auth_enable = yes" >> /etc/postfix/main.cf \
              || $sedpath -i 's/^smtp_sasl_auth_enable.*/smtp_sasl_auth_enable = yes/g' /etc/postfix/main.cf
          [[ "$($greppath -c ^smtp_sasl_security_options </etc/postfix/main.cf)" == "0" ]] \
              && printf "smtp_sasl_security_options = noanonymous" >> /etc/postfix/main.cf \
              || $sedpath -i 's/^smtp_sasl_security_options.*/smtp_sasl_security_options = noanonymous/g' /etc/postfix/main.cf
          [[ "$($greppath -c ^smtp_sasl_password_maps </etc/postfix/main.cf)" == "0" ]] \
              && printf "smtp_sasl_password_maps = hash:/etc/postfix/sasl_passwd" >> /etc/postfix/main.cf \
              || $sedpath -i 's/^smtp_sasl_password_maps.*/smtp_sasl_password_maps = hash:\/etc\/postfix\/sasl_passwd/g' /etc/postfix/main.cf
          [[ "$($greppath -c ^smtp_tls_security_level </etc/postfix/main.cf)" == "0" ]] \
              && printf "smtp_tls_security_level = encrypt" >> /etc/postfix/main.cf \
              || $sedpath -i 's/^smtp_tls_security_level.*/smtp_tls_security_level = encrypt/g' /etc/postfix/main.cf
          [[ "$($greppath -c ^smtp_tls_CAfile </etc/postfix/main.cf)" == "0" ]] \
              && printf "smtp_tls_CAfile = /etc/postfix/cacert.pem" >> /etc/postfix/main.cf \
              || $sedpath -i 's/^smtp_tls_CAfile.*/smtp_tls_CAfile = \/etc\/postfix\/cacert.pem/g' /etc/postfix/main.cf
          [[ "$($greppath -c ^[[]"${line%:*}"".""$outemailprovider""]:""${line#*:}" </etc/postfix/sasl_passwd)" == "0" ]] \
              && printf "[""${line%:*}"".""$outemailprovider""]:""${line#*:}""    $outemailadd":"$outemailpw" >> /etc/postfix/sasl_passwd \
              || $sedpath -i 's/^[[]'"${line%:*}.$outemailprovider]:${line#*:}"'.*/'"[${line%:*}.$outemailprovider]:${line#*:}     $outemailadd:$outemailpw"'/g' /etc/postfix/sasl_passwd
          [[ "$($greppath -c ^smtp_generic_maps </etc/postfix/main.cf)" == "0" ]] \
              && printf "smtp_generic_maps = hash:/etc/postfix/generic" >> /etc/postfix/main.cf \
              || $sedpath -i 's/^smtp_generic_maps.*/smtp_generic_maps = hash:\/etc\/postfix\/generic/g' /etc/postfix/main.cf
          [[ "$($greppath -c ^root@$(hostname) </etc/postfix/generic)" == "0" ]] \
              && printf "root@$(hostname)           $outemailadd" >> /etc/postfix/generic \
              || $sedpath -i 's/^'"root@$(hostname)"'.*/'"root@$(hostname)           $outemailadd"'/g' /etc/postfix/generic
          chown postfix /etc/postfix
          chown postfix /etc/postfix/generic
          chmod 600 /etc/postfix/sasl_passwd
          eval "$postmappath /etc/postfix/sasl_passwd"
          eval "$postmappath /etc/postfix/generic"
          chown root:root /etc/postfix/sasl_passwd /etc/postfix/sasl_passwd.db
          chmod 600 /etc/postfix/sasl_passwd.db
          chmod 644 /etc/postfix/cacert.pem
          chmod 644 /etc/postfix/master.cf
          cat /etc/ssl/certs/Thawte_Premium_Server_CA.pem | tee -a /etc/postfix/cacert.pem 1&>/dev/null
          chown postfix /etc/postfix/sasl_passwd*

          [[ $(/etc/init.d/postfix reload >/dev/null;echo $?) == "0" ]] || /etc/systemctl restart postfix

          if ! [[ "$( $postqueuepath -p )" == *is\ empty* ]];then
               printf "For the next step, the mail queue needs to be flushed.  You will lose the\
\nfollowing emails that haven't been sent.  Press a key to acknowledge..."
               printf "$( $postqueuepath -p )"
               read -rsn 1;read -rst 0.001 -n3
               printf "$( $postqueuepath -f )"
          fi
          printf "Next, suitability test notifications will be sent out to all email addresses you\
\nindicated should receive notifications.  Press a key to send them..."
          read -rsn 1;read -rst 0.001 -n3
          notemsg=""
          [[ $answer =~ f ]] && notemsg+="Firewalling\n"
          [[ $answer =~ e ]] && notemsg+="Email remote control\n"
          [[ $answer =~ d ]] && notemsg+="Dynamic IP address change notifier\n"
          [[ $answer =~ p ]] && notemsg+="Port knocking\n"
          printf "Test using "${line%:*}"".""$outemailprovider"":""${line#*:}" \
\nas outgoing email server from firewall/dynamic IP notifier \
\nItems being installed:\n$( printf "${notemsg:: -2}" )"|$mailpath -s "Test notification from firewall install script" "$(echo "${toemailadds:: -2}"|$sedpath 's/\\n/,/g')"
#          cat \
<< See
If error: SASL authentication failed; server smtp.gmail.com,
you need to unlock the captcha by visiting this page \
https://www.google.com/accounts/DisplayUnlockCaptcha
See
#          sleep 2
           [[ "$( $postqueuepath -p )" == *is\ empty* ]] \
            && printf "All emails sent just fine.  Have they all been received in a timely manner?  If\
\nany were delayed, a different outgoing email server may do a better job." \
            || printf "Judging by the email queue not getting emptied quickly, a different outgoing\
\nemail server may do a better job.\n$($tailpath /var/log/syslog|$greppath postfix|$greppath ${line%:*}.$outemailprovider|$greppath -m 1 \]:${line#*:}|$sedpath 's/^.*status=//g')"
# \nemail server may do a better job.\n$($tailpath /var/log/syslog|$greppath postfix|$greppath ${line%:*}.$outemailprovider|$greppath -m 1 \]:${line#*:}|sed 's/^.*status=//g')"
          printf "\nNote that not all email providers keep a record of your emails sent from this\
\ntype of connection.  If it is meaningful to you that these notification emails\
\nremain in the sent folder of this email address, be sure to check for that\
\nfeature before accepting this outgoing email server.  Press ENTER key to accept\
\nthis outgoing email server, any other key to see if another one can be tested..."
          [[ "$(until IFS= read -s -n1 -t .1 domore;[[ "$?" == "0" ]] && echo ${#domore};do :;done)" -eq 0 ]] && break 2 # Didn't want to mess with IFS but had to to accept and know diff between space and enter
     done 3<"$directoryforscripts/$outemailprovider.outconnects.txt"  2> /dev/null #if needed to for chosen email account, this loop iterates through lines in outconnects.txt 
# user wants a to re-select an email address
             printf "Select a different email address for its outgoing email server:"
done #this loop goes through the email provider outbound servers & builds connect.txt files until user selects one
echo "$outemailadd" > "$directoryforscripts/outemailadd"
chmod 600 "$directoryforscripts/outemailadd"
fi
postfix_already_conf=True # set this to True or just anything non-empty
          }

          install_rc () {
directoryforscripts="$( cat directoryforscripts )"
# "$($sedpath 's/,/\n/g' <"$directoryforscripts/toemailadds")"
inemailadds=""
inemailadds="$( [[ -f "$directoryforscripts/outemailadd" ]] && cat "$directoryforscripts/outemailadd" || [[ -f "$directoryforscripts/toemailadds" ]] && $sedpath 's/,/\n/g' <"$directoryforscripts/toemailadds" )"
#WORKING ON: nice selector from "$directoryforscripts/successlogins"

inemailacct="${inemailadd%@*}";inemailprovider="${inemailadd#*@}";inemaildomain="${inemailprovider%.*}";intopdomain="${inemailprovider#*.}";inemailsubdomain="pop";
# rm "$directoryforscripts/successlogins" 2>/dev/null
clear
while true;do
     printf "(Be advised - The next configuration will determine the optimal port of an email\
\nserver to connect to when retrieving emailed instructions.  You should now\
\nensure that your Internet connection is the same one that will be used in final\
\noperation if your email account will be hosted by your local ISP.  The email\
\naccount, that is, that this server will read instructions out of.)\
\n\n  Enter the email address now from which this system will retrieve instructions\
\nto itself that you or others will send:\n"
#     printf "$line"
     get_1_addr_from_bunch $inemailadds
          inemailadd="emailadd";inemailacct="$emailacct";inemaildomain="$emaildomain";intopdomain="$topdomain";inemailprovider="$emailprovider";inemailpw="$emailpw"
              printf "Configuring for that email account.  Remember, you should be doing\
\nthis step from the Internet location of final operation if you have/want your\
\nlocal ISP-provided email account considered for this...\n"
              [[ -f "$directoryforscripts/$inemailprovider.inconnects.txt" ]] \
                 && rm "$directoryforscripts/$inemailprovider.inconnects.txt" 2>/dev/null
              printf  "\rYou selected address $inemailacct \033[K\n"
              while ! [[ "$(dig +short myip.opendns.com @resolver1.opendns.com)" =~ ^((1?[0-9]?[0-9]|2[0-4][0-9]|25[0-5])\.){3}(1?[0-9]?[0-9]|2[0-4][0-9]|25[0-5])$ ]];do
                  printf "\r\033[KNo internet connection found with full DNS.  Press a key when corrected...";read -n1 -s
              done
              while ! [[ -f "$directoryforscripts/$inemailprovider.inconnects.txt" ]];do # this loop re-tries if no connection file is created in the loop
                  exec 5>&-;wait
                  for MAIL_PROT in pop pop3 mail;do
                       for port in 465 995 110 993;do
                            printf "\rChecking $MAIL_PROT.$inemailprovider:$port\033[K";
                            (./timeout.sh -t 2 "exec 5>&-;exec 5<>/dev/tcp/$MAIL_PROT.$inemailprovider/$port;read -u 5 HELO;! [[ -z \$HELO ]] && printf \"$MAIL_PROT:$port\" >> \"$directoryforscripts/$inemailprovider.inconnects.txt\";printf \"quit\" >&5;read -t 2 -u 5 QUIT;exec 5>&-")
                       done  2> /dev/null
                  done
                  if [[ -f "$directoryforscripts/$inemailprovider.inconnects.txt" ]];then
                       printf "\rThe possibilities are\033[K\n$(<"$directoryforscripts/$inemailprovider.inconnects.txt")"
                  else
                       printf "\r\033[K\033[2ASelected email provider isn't allowing an initial connection right now, or maybe\
\nthe Internet connection is faulty.  Press Ctrl-c to abort retries...\n"
# We need a better way to interrupt this
                       continue
                  fi
              done
# echo;printf "Address is\n\n$inemailacct"@"$inemaildomain"."$intopdomain"
          rcpw="";rcpw1=""
          while printf "Password for that email account:";read -s rcpw;do # This loop is for when a password is under question
              printf "\n\033[KRe-type password:"
              read -s rcpw1
              printf "\r\033[K\033[1A\033[K"
              [[ -z "$rcpw$rcpw1" ]] && break 2
              ! [[ "$rcpw" == "$rcpw1" ]] && continue
              rm fifo 2>/dev/null
# mkfifo fifo doesn't function ideally
              while read -u 3 -r line;do #? this while loop iterates once for each port that accepted a pop connection ${line%:*}"."$outemailprovider"]:"${line#*:}
                  while true;do # This loop for exact settings retry
                      exec 5>&-;wait
                      exec 5<>/dev/tcp/"${line%:*}.$inemailprovider/${line#*:}"
                      printf "\rExecuted the connect of ${line%:*}.$inemailprovider/${line#*:}, now communicating with it for user $inemailacct...\033[K"
                      read -t 2 -u 5 HELO 
                      printf "$HELO" >> fifo 
# printf "\n$HELO"
                      msgnumber=0
                      for msg in "user $inemailacct\r" "pass $rcpw\r" stat list;do
                           msgnumber=$(( msgnumber+=1 ))
                           printf "\r\033[KSending $msg\n"
                           printf "$msg" >&5
                         #  while true;do # this loop stores server responses for a configuration
# using 'cat <&5' would probably timeout on most single-line reads
                           while (read -u 5 replyline
                                  printf "\r\033[K$replyline\n"
                                  echo "$replyline" >> fifo 
                                  ! [[ "${replyline:0:1}" == "+" ]] && break # ! [[ "${replyline:0:1}" == "+" ]] && break
                                 ) &
                                pid="$!"
                           do
                                sleep 2 &
                                sid="$!"
                                until ! [[ $(kill -0 "$pid";echo "$?") == "0" ]] || ! [[ $(kill -0 "$sid";echo "$?") == "0" ]]; do
                                :
                                done
                                if [[ $(kill -0 "$pid";echo "$?") == "0" ]];then
                                    kill "$pid" >/dev/null
                                    break
                                else
                                    break
                                fi
                           done 2>/dev/null
                      done
                      printf "quit\r" >&5 
                      read -t 2 -u 5 BYE
#                      printf "$BYE" >> fifo 
                      exec 5>&-
                      if ! [[ "$( replystart="$($tailpath -n 1 fifo)";echo "${replystart::1}")" == "+" ]];then # present this choice with every error
                         printf "Unsuccessful sign-in of $inemailacct to ${line%:*}.$inemailprovider/${line#*:}" # with this error:\n$($tailpath -n 1 fifo)"
                         printf "quit\r" >&5
                         read -t 2 -u 5 BYE
#                          printf "$BYE" >> fifo 
                         exec 5>&-
                         printf "If you're sure about the password, and there are more port options for this\
\nemail account, option 'N' would make the most sense.  Try a new email Address, a\
\nnew Password, the Next possibility, same Everything, or Quit\
\n(A, P, N, E, or Q)..."
                         read -n1 retryansw # 4 does new pw, 0,1 goes into new pw
                         loops="A3P2N1E0Q4";loops="${loops#*${retryansw^}}"
                         echo
                         ! [[ "${loops::1}" == "0" ]] && continue "${loops::1}"
                      else
                         printf "$inemailacct ${line%:*}.$inemailprovider/${line#*:}" >> "$directoryforscripts/successlogins"
                         break
                      fi
                  done # This loop for exact settings retry
              done 3<"$directoryforscripts/$inemailprovider.inconnects.txt" 2> /dev/null
            # if we have even a single success, break
                     [ -f "$directoryforscripts/successlogins" ] && break 2
          done # This loop is for when a password is under question
done # This loop is to change the account
toemailadds=$( cat "$directoryforscripts/toemailadds" )
#     printf "\n\nLet's look at the results:\n"
#     cat fifo
#     rm fifo 2>/dev/null
           (cat <<EOF
#!/bin/bash

# THIS SCRIPT ALLOWS FOR CONTROL VIA EMAIL
# I suggest it be launched with a special port
# knock logged in kern.log by virtue of an
# iptables rule in the INPUT chain that
# identifies itself with the term "email-reader"
# in its comments. The script searching for that
# port-match and launching this script is called
# process_source_ip.sh.  By maintaining a dynamic
# blacklist for a while you'll better be able
# to determine a good port for you.

# The controlling email should be already sent
# before knocking said port because this
# script has no way of knowing for sure that
# an email will come in a timely manner.

# Numerous grep commands are contained herein
# that could be refined to use separate text
# files to hold the search terms/keywords. I did
# not so refine them simply to minimize the
# number of files in this project since I am
# targeting users who might get lost in
# an excessive number of files.  I would
# encourage you to modify those grep commands
# yourself if you value the finer points of
# programming.

# Example: (roughly, please don't criticize imperfection between the lists)
#     echo "\$(grep -e "Content-Type: text/plain; charset=UTF-8" -iwe "remove" -e "undo" -e "delete" -e "whitelist" -e "permit" -e "let" -e "on" -e "open" -e "allow" -e "blacklist" -e "off" -e "stop" -e "block" -e "recent" -e "report" -e "shut" -e "close" -e "prevent" -e "recent" -e "me" -e "report" -e "what" -e "who" -e "whoami" -e "kern" -e "kernlog" -e "kern.log" <(echo "\$mailcontentline"))" >> $directoryforscripts/mailcontent
#
# becomes (except the email content header line becomes case-insensitive along with everything else):

#     cat *.keywords > allwords.tmp; echo "\$(grep -wif allwords.tmp <(echo "\$mailcontentline"))" >> "$directoryforscripts/mailcontent";rm allwords.tmp
#       -the grep -f flag is what does it
#
# given the following files exist in the appropriate directory, and
# there are no empty lines in the files, including the last ones:

#    'emailbegins.keywords' having the following contents: (case becomes insensitive if following the example given)
#       Content-Type: text/plain; charset=UTF-8

#    'blacklistlog.keywords' having the following contents:
#       log
#       logging

#    'tailkernlog&emailresults.keywords' having the following contents:
#       recent
#       report
#       kern
#       kernlog
#       kern.log
#       tail
#       who
#       whoami
#       what
#       me

#    'deleting.keywords' having the following contents:
#       remove
#       undo
#       delete
#       end
#       stop

#    'blacklisting.keywords' having the following contents:
#       blacklist
#       off
#       block
#       shut
#       close
#       prevent

#    'whitelisting.keywords' having the following contents:
#       whitelist
#       permit
#       let
#       on
#       open
#       allow

[ \$(( \$($tailpath -n-2 \$0|$greppath -c "^#running"))) -gt 0 ] && exit
until [ \$(( \$($tailpath -n-2 \$0|$greppath -c "^#running"))) -gt 0 ];do
      echo "#running" >> \$0
      sleep 1
done
trap "$sedpath -i '/^\#running/d' \$0" EXIT
[[ \$- = *i* ]] && echo "Connecting to email...."
port="${line#*:}";MAIL_PROT="${line%:*}"
MAIL_FROM="$inemailacct@$inemailprovider"
[ ! -z \$2 ] && [ -z "\${2//[0-9]}" ] && [ \$2 -ge 0 ] && [ \$2 -le 65535 ] &&  port=\$2
[ ! -z \${3,S} ] && [ \${3,S} == "s" ] && MAIL_PROT="smtp"
[ ! -z \${3,S} ] && [ \${3,I} == "i" ] && MAIL_PROT="imap"
accountname="\${MAIL_FROM%%@*}";domainname="\${MAIL_FROM##*@}"
exec 5>&-;wait
exec 5<>/dev/tcp/\$MAIL_PROT"."\$domainname/\$port
[[ \$- = *i* ]] && echo "Executed the connect, now trying to read..."
read -t 2 -u 5 HELO # <&5
[ x\$1 == "x-v" ] && printf "GOT: \\n\$HELO"
[ x\$1 == "x-v" ] && echo "SENDING: username"
printf "user $inemailacct\\r" >&5
read -t 2 -u 5 sendyourpassword
[ x\$1 == "x-v" ] && echo "\$sendyourpassword"
[ x\$1 == "x-v" ] && echo "SENDING: password"
printf "pass $rcpw\\r" >&5
read -t 2 -u 5  maildroplockedandready
[ x\$1 == "x-v" ] && echo "\$maildroplockedandready"
[ x\$1 == "x-v" ] && echo "SENDING: list"
printf "list\\r" >&5
[ -f "$directoryforscripts/mailcontent" ] && rm "$directoryforscripts/mailcontent"
numofemails=-1
while read  -t 2 -u 5 emailtitle; do
    [ \$(( \${#emailtitle} )) -lt 3 ] && break
    if [ \$(( \${#emailtitle} )) -lt 20 ]; then
         #add to array of emailtitlnums
         numofemails=\$(( \$numofemails + 1 ))
         [ x\$1 == "x-v" ] && echo "\$numofemails"
         emailtitlenums[ \$((numofemails)) ]=\${emailtitle% *}
    fi
done
if [ \$((numofemails)) -gt -1 ]; then
    [[ \$- = *i* ]] && echo "Retrieving \$numofemails email[s]..."
    for i in \`seq 0 \$((numofemails))\`;do
         printf "RETR \${emailtitlenums[i]}\\r" >&5
          boundary=""
          while read  -t 2 -u 5 mailcontentline;do
             [ \$(( \${#mailcontentline} )) -lt 2 ] && continue
             mailcontentline="\${mailcontentline:: -1} " #strip the linefeed and put space there instead
              [[ \$- = *i* ]] && echo "\$mailcontentline" #
              if [ -z "\$boundary" ];then [ \$(echo "\$mailcontentline"|$greppath -e "^Content-Type: "|$greppath -c "; boundary=") -gt 0 ] && boundary="\$(echo "\$mailcontentline"|$greppath -e "^Content-Type: " -e "; boundary="|$awkpath -F= '{print \$2}')" && boundarymarker=1
              else
                  echo "\$($greppath -iwe "remove" -e "undo" -e "delete" -e "whitelist" -e "permit" -e "let" -e "on" -e "open" -e "allow" -e "blacklist" -e "off" -e "stop" -e "block" -e "recent" -e "report" -e "shut" -e "close" -e "prevent" -e "recent" -e "me" -e "report" -e "what" -e "who" -e "whoami" -e "kern" -e "kernlog" -e "kern.log" -e "log" -e "end" -e "logging" <(echo "\$mailcontentline"))"|while read line;do [ \$(( \${#line} )) -gt 1 ] && echo "\$line" >> "$directoryforscripts/mailcontent";done
                  [ \$($bcpath <<<"\${#mailcontentline} - \${#boundary}") -eq 2 ] && [ "\${mailcontentline:2: -1}" == "\${boundary:: -1}" ] && [ \$(( ++boundarymarker )) -gt 2 ] && (read  -t 2 -u 5 mailcontentline;read -t 2 -u 5  mailcontentline;read  -t 2 -u 5 mailcontentline;read -t 2 -u 5 mailcontentline) && break # && echo "Retrieved one message" && break
              fi
          done
    done
    for i in \`seq 0 \$((numofemails))\`;do
         printf "dele \${emailtitlenums[i]}\\r" >&5
         while read -t 2 -u 5 deleteresponse;do [ \$(( \${#deleteresponse} )) -lt 1 ] && break;done
    done
     [ -f "$directoryforscripts/valid_instructions_from_email" ] && rm "$directoryforscripts/valid_instructions_from_email"
#This will give us the subject line of first email: head -n+\$(( \$($greppath -m 1 --line-number "Content-Type: text/plain; charset=UTF-8" < mailcontent|$awkpath -F: '{print \$1}') - 1)) mailcontent|$greppath -E '^Subject'
#This will start us at content of first email: $tailpath -n+\$(( 2 + \$($greppath -m 1 --line-number "Content-Type: text/plain; charset=UTF-8" < mailcontent|$awkpath -F: '{print \$1}'))) mailcontent
     cat "$directoryforscripts/mailcontent" |while read line; do line1="\$(echo "\$line "|$greppath -E -o "\\b((1?[0-9]?[0-9]|2[0-4][0-9]|25[0-5])\\.){3}(1?[0-9]?[0-9]|2[0-4][0-9]|25[0-5])( |/[1-2]?[0-9] |/3[0-2] )")" && ( echo "\$line1"|while read ipadd;do echo "\$ipadd \$line" >> "$directoryforscripts/valid_instructions_from_email"; done ) || (line1="\$(echo "\$line"|$greppath -wie "recent" -e "me" -e "report" -e "what" -e "who" -e "whoami" -e "kern" -e "kernlog" -e "kern.log" -e "tail" -e "log")" && ( echo "\$line1" >> "$directoryforscripts/valid_instructions_from_email" ));done
     cat "$directoryforscripts/valid_instructions_from_email" |while read line
     do option=""
          [ \$($greppath -cwie "undo" -e "remove" -e "delete" -e "end" -e "stop" <(echo "\$line")) -gt 0 ] && option="-r"
          if [ \$($greppath -cwie "report" -e "send" <(echo "\$line")) -gt 0 ] && [ \$($greppath -cwi "whitelist" <(echo "\$line")) -gt 0 ];then
              script="echo \\"\$($iptablespath -wnvL s_whitelist|$awkpath '{print \$8}')\\"|mail -s \\"As you requested\\" \\"$toemailadds\\""
          elif [ \$($greppath -cwie "recent" -e "report" -e "kern" -e "kernlog" -e "kern.log" -e "tail" -e "who" -e "whoami" -e "what" -e "me" <(echo "\$line")) -gt 0 ];then
              script="echo \\"\$($tailpath /var/log/kern.log)\\"|mail -s \\"As you requested\\" \\"$toemailadds\\""
          elif [ \$($greppath -cwie "permit" -e "let" -e "on" -e "open" -e "allow" -e "whitelist" <(echo "\$line")) -gt 0 ]; then
              script="$directoryforscripts/openall.sh \$(echo \$line|$awkpath '{print \$1}') \$option \\"via email \$(date)\\""
          elif [ \$($greppath -cwie "log" -e "logging" <(echo "\$line")) -gt 0 ];then
              if [ \$(( \${#option} )) -eq 0 ];then script="$iptablespath -wI INPUT \$($iptablespath -wnL INPUT --line-numbers|$greppath "s_privateIPs"|$awkpath '{print \$1 + 1}') -m comment --comment \\"via email \$(date) - remove when not needed\\" -j LOG"
              elif [ \$($iptablespath -wnL INPUT|$greppath -c "remove when not needed") -gt 0 ];then script="[[ \$($iptablespath -wnL INPUT --line-numbers|$greppath -m 1 "remove when not needed"|$awkpath '{print \$1}') -gt 0 ]] && $iptablespath -wD INPUT \$($iptablespath -wnL INPUT --line-numbers|$greppath -m 1 "remove when not needed"|$awkpath '{print \$1}')"
              else
                  script=""
              fi
              [ \$(( \${#script} )) -ne 0 ] && echo "\$script" >> "$directoryforscripts/buildiptables.sh"
          else
              script="$directoryforscripts/process_source_ipt.sh \$(echo \$line|$awkpath '{print \$1}') \$option \\"via email \$(date)\\""
          fi
          echo "$directoryforscripts/email_fetch_parse is sending the following command to be executed:" >> "$directoryforscripts/email_fetch_parse.log"
          echo "\$script"  >> "$directoryforscripts/email_fetch_parse.log"
          [ \$(( \${#script} )) -ne 0 ] && eval "\$script"
     done
else
     [[ \$- = *i* ]] && echo "No emails were in the inbox"
fi
[[ \$- = *i* ]] && echo "SENDING: QUIT"
printf "QUIT\\r" >&5
wait
exec 5>&-
EOF
) > "$directoryforscripts/email_fetch_parse"
chmod 700 "$directoryforscripts/email_fetch_parse"
# TODO: iptables entry to log port knock for email reader
# belongs inserted just before both whitelist and blacklist - use the lower line number of them both
line_number_for_email_reader="$($iptablespath -wnvL INPUT --line-number|$awkpath 'NR>2 {print $1" "$4}'|$greppath -e s_whitelist -e s_blacklist|$sortpath -k1n|$awkpath 'NR==1 {print $1}')"
until read -erp "Enter a port number you will knock to initiate email to be read" emailport; [[ "$emailport" =~ ^[0-9]{1,5}$ ]] && [[ $(( $emailport )) -le 65535 ]];do
    printf "\nThe port number must be a number between 0 and 65535 inclusive\n"
done
[[ $($iptablespath -wI INPUT $line_number_for_email_reader -p all --dpt $emailport -m comment --comment "This rule ensures email-reader port knock won't get ignored" -j LOG --log-prefix "fetch email " 2>/dev/null;echo "$?") == "0" ]] || printf "Failed 22"
          }
install_dynIPch () {
#dhcp_lease_path
# mac=ipconfig getpacket (interface name)
#dhcp_message_type (uint8): ACK 0x5
#server_identifier (ip): 192.168.0.1
#lease_time (uint32): 0xf20
#subnet_mask (ip): 255.255.255.0
#router (ip_mult): {192.168.0.1}
#domain_name_server (ip_mult): {116.1.12.4, 116.1.12.5}
#end (none): 
#dhclient:
#Listening on LPF/$external_net_interface:avahi/00:26:b9:ef:57:dd
#Sending on   LPF/$external_net_interface:avahi/00:26:b9:ef:57:dd
#Listening on LPF/wlan0/5c:ac:4c:29:53:d0
#Sending on   LPF/wlan0/5c:ac:4c:29:53:d0
#Listening on LPF/$external_net_interface/00:26:b9:ef:57:dd
#Sending on   LPF/$external_net_interface/00:26:b9:ef:57:dd
#Sending on   Socket/fallback
#DHCPDISCOVER on $external_net_interface:avahi to 255.255.255.255 port 67 interval 3 (xid=0xde511649)
#DHCPREQUEST of 10.100.100.173 on wlan0 to 255.255.255.255 port 67 (xid=0x275b221c)
#DHCPDISCOVER on $external_net_interface to 255.255.255.255 port 67 interval 3 (xid=0x2727213c)
#DHCPACK of 10.100.100.173 from 172.22.0.5
#RTNETLINK answers: File exists
#bound to 10.100.100.173 -- renewal in 9225 seconds.
#
#read /etc/network/interfaces
#OS X=/Library/Preferences/SystemConfiguration/preferences.plist
# centos: 
# udhcpc: /var/lib/misc/udhcpc-$external_net_interface.leases or /var/cache/udhcpc-$external_net_interface.lease, not really clear for embedded linux's.  This is an important one to get right
# dhcpcd: /etc/dhcpc/dhcpcd-$external_net_interface.info
# pump: in memory alone, need to parse ps uax output
# dhclient: /var/lib/NetworkManager/*.lease*, or /var/lib/dhcp/dhclient. or on FreeBSD /var/db/*lease*
# /var/lib/dhcp3/dhclient.%iface%.leases
#if [[ $(( cat $(ls /var/lib/dhclient/*.lease* /var/lib/dhcp/*.lease* /var/lib/dhcp3/*.lease* /var/lib/NetworkManager/*.lease* /var/lib/dhcpcd/*$external_net_interface* /var/db/*lease* 2>/dev/null|$greppath -w "$external_net_interface")|$greppath -w $($ippath -o route get 8.8.8.8|$awkpath '{ print $7 }')|$wcpath -l )) -eq 0 ]] && \
#[[ $(( cat $(ls /var/lib/dhclient/*.lease* /var/lib/dhcp/*.lease* /var/lib/dhcp3/*.lease* /var/lib/NetworkManager/*.lease* /var/db/*lease* 2>/dev/null|$greppath -vw "$internal_net_interface")|$greppath -wC 3 $($ippath -o route get 8.8.8.8|$awkpath '{ print $5 }')|$greppath -w $($ippath -o route get 8.8.8.8|$awkpath '{ print $7 }')|$wcpath -l  )) -eq 0 ]];then
#[[ $(( dhclient -v $external_net_interface|$wcpath -l 2>/dev/null )) -gt 0 ]]
# get the ip address of $external_net_interface from ip route or ifconfig or ipconfig
#   /etc/network/interfaces, grep for lines tno starting w/# and referencing googleinterface that say 'static' orf 'dhcp'
# static int dhcp_up(interface_defn *ifd, execfn *exec) {
# {
#   if (!execute("[[ifconfig %iface% hw %hwaddress%]]", ifd, exec)) return 0;
# }
# if ( execable("/sbin/dhclient3") ) {
# if (!execute("dhclient3 -pf /var/run/dhclient.%iface%.pid -lf /var/lib/dhcp3/dhclient.%iface%.leases %iface%", ifd, exec)) return 0;
# }
# else if ( execable("/sbin/dhclient") ) {
# if (!execute("dhclient -v -pf /var/run/dhclient.%iface%.pid -lf /var/lib/dhcp/dhclient.%iface%.leases %iface%", ifd, exec)) return 0;
# }
# else if ( execable("/sbin/pump") && mylinuxver() >= mylinux(2,1,100) ) {
# if (!execute("pump -i %iface% [[-h %hostname%]] [[-l %leasehours%]]", ifd, exec)) return 0;
# }
# else if ( execable("/sbin/udhcpc") && mylinuxver() >= mylinux(2,2,0) ) {
#   if (!execute("udhcpc -n -p /var/run/udhcpc.%iface%.pid -i %iface% [[-H %hostname%]]            [[-c %client%]]", ifd, exec)) return 0;
# }
# else if ( execable("/sbin/dhcpcd") ) {
# if (!execute("dhcpcd [[-h %hostname%]] [[-i %vendor%]] [[-I %client%]]            [[-l %leasetime%]] %iface%", ifd, exec)) return 0;
# }
# 
#FIRST: LOOK FOR PS AUX OUTPUT THAT EVIDENCES THAT IFACE IS SERVED BY ONE OF THE DHCP CLIENTS, IF NEED BE THEN ENSURE NO 'STATIC' IN /etc/network/interfaces FOR THAT IFACE as in:
# /sbin/dhclient -d -sf /usr/lib/NetworkManager/nm-dhcp-client.action -pf /run/sendsigs.omit.d/network-manager.dhclient-wlan0.pid -lf /var/lib/NetworkManager/dhclient-58a215d6-1342-4ce9-8da8-e75dab5b68c3-wlan0.lease -cf /var/lib/NetworkManager/dhclient-wlan0.conf wlan0
directoryforscripts="$( cat directoryforscripts )"
dhcpclientpath=""
for dhcpclientpkg in "pump -i $external_net_interface --status" "udhcpc -i $external_net_interface" "dhcpcd $external_net_interface" "ipconfig getpacket $external_net_interface" "dhclient -v $external_net_interface";do
    dhcpclientpath="$($whereispath $binaryflag ${dhcpclientpkg%% *})"
    dhcpclientpath="${dhcpclientpath##*:}"
    [[ -z "$dhcpclientpath" ]] && continue
    dhcpclientpath="${dhcpclientpath# }"
    dhcpclientpath="${dhcpclientpath%% *}"
    echo "Executing <$dhcpclientpath ${dhcpclientpkg#* }>"
exit
    $($dhcpclientpath ${dhcpclientpkg#* } | $greppath -i renew ) # |$greppath  # since there could be several dhcp clients installed we know only one will be working, eliminate non-working ones
done
if [[ -z "$dhcpclientpath" ]];then
    printf "Unable to verify that the Internet-pointing interface is a DHCP client.  If said\
\ninterface is not using DHCP as a DHCP client, there is no point in installing\
\nthis feature.  If it IS a dhcp client, then the finding of this script is in\
\nerror, and you'll have to modify this script to so it learns how to detect and\
\nmonitor for DHCP changes specific to your system.  Exiting now..."
    exit
fi

if ! [[ -z "$toemailaddsIP" ]];then
     echo "$(echo "${toemailaddsIP:: -2}"|$sedpath 's/\\n/,/g')" > "$directoryforscripts/toemailaddsIP"
     break
fi
# "$directoryforscripts/newdynip.sh"
printf "The notification email you'd receive should refer to this computer by what name?"
pcname=$(while read -e -r -i "$(hostname)" sysname;do if ! [[ -z "$sysname" ]];then echo "$sysname";break;fi;done)
echo
if [[ "$(dig +short myip.opendns.com @resolver1.opendns.com)" =~ ^((1?[0-9]?[0-9]|2[0-4][0-9]|25[0-5])\.){3}(1?[0-9]?[0-9]|2[0-4][0-9]|25[0-5])$ ]];then 
     printf "To learn any new IP address gotten, this computer will interrogate a public\nservice, \
default is shown below.  Press enter to keep it; otherwise, change it\nto suit you:"
else 
     printf "To learn any new IP address gotten, this computer will interrogate a public\nservice, \
default is shown below, but is NOT WORKING now.  Change it to suit you:"
fi
resolver="$(while read -e -i "dig +short myip.opendns.com @resolver1.opendns.com" resolver;do 
     echo "$resolver";break;
done)"
printf "\nEmail address[es] where to send IP change notifications to:\n"
toemailaddsIP="$($sedpath 's/,/\n/g' <"$directoryforscripts/toemailaddsIP")"
scratchpad="${toemailaddsIP##*'\n'}"
line="${toemailaddsIP##*'\n'}";printf "$line"
toemailaddsIPid=1
              while IFS= read  -rsn1 char;do
                   if [[ "$(printf "%d" "'$char")" == "27" ]];then # '
                         char1="";char2="";char3=""
                         read -rst 0.001 -n1 char1
                         read -rst 0.001 -n1 char2
                         read -rst 0.001 -n1 char3
                         if [[ "$char1$char2$char3" == "[A" ]] || [[ "$char1$char2$char3" == "[B" ]];then
                              if [[ "$char1$char2$char3" == "[A" ]];then
                                   toemailaddsIPid=$(( $toemailaddsIPid - 1 ))
                              else
                                   toemailaddsIPid=$(( $toemailaddsIPid + 1 ))
                              fi
                              if [[ $(( $toemailaddsIPid )) -lt 1 ]];then
                                    toemailaddsIPid=$(( $toemailaddsIPid + 1 ))
                                    continue
                              fi
                              scratchpad="$toemailaddsIP"
                              for i in `seq 2 $(( $toemailaddsIPid ))`;do
                                   ! [[ -z "${scratchpad#*'\n'}" ]] \
                                       && scratchpad="${scratchpad#*'\n'}" \
                                       || toemailaddsIPid=$(( $toemailaddsIPid - 1 ))
                              done
                              scratchpad="${scratchpad%%'\n'*}"
                              printf "\r${scratchpad}\033[K"
                              horizptr="$(( ${#scratchpad} ))"
                         elif [[ "$char1$char2$char3" == "[C" ]];then
                              if [[ $(( ${horizptr} )) -lt $(( ${#scratchpad} )) ]];then
                                    horizptr="$(( ${horizptr} + 1 ))"
                                    printf "\033[1C"
                              fi
                         elif [[ "$char1$char2$char3" == "[D" ]];then
                              if [[ $(( ${horizptr} )) -gt 0 ]];then
                                    horizptr="$(( ${horizptr} - 1 ))"
                                    printf "\033[1D"
                              fi
                         elif [[ "$char1$char2$char3" == "OF" ]];then
                              horizptr="$(( ${#scratchpad} ))"
                              printf "\r\033[${#scratchpad}C"
                         elif [[ "$char1$char2$char3" == "OH" ]];then
                              horizptr="0"
                              printf "\r"
                         elif [[ "$char1$char2$char3" == "[3~" ]];then
                              if [[ $(( ${horizptr} )) -lt $(( ${#scratchpad} )) ]];then
                                   scratchpad="${scratchpad:0:horizptr}${scratchpad:horizptr+1}" # handles the delete character
                                   printf "${scratchpad:horizptr}\033[K\r${scratchpad:0:horizptr}"
                              fi
                         fi
                   elif [[ "$(printf "%d" "'$char")" == "127" ]];then # '
                     if ! [[ $(( ${horizptr} )) -eq 0 ]];then # exit
                         horizptr="$(( ${horizptr} - 1 ))"
                         scratchpad="${scratchpad:0:horizptr}${scratchpad:horizptr+1}" # handles the backspace character
                         printf "\033[1D${scratchpad:horizptr}\033[K\r${scratchpad:0:horizptr}"
                     fi
                   elif [[ -z "$char" ]];then
                         break
                   else
                        horizptr="$(( ${horizptr} + 1 ))"
                        scratchpad="${scratchpad:0:horizptr-1}$char${scratchpad:horizptr-1}"
                        printf "$char${scratchpad:horizptr}\033[K\r${scratchpad:0:horizptr}"
                   fi
              done
              outemailadd="${scratchpad%%'\n'*}"
              outemailacct="${outemailadd%@*}";outemailprovider="${outemailadd#*@}"
              outemaildomain="${outemailprovider%.*}"
              outtopdomain="${outemailprovider##*.}"
              if ! [[ "$outemailadd" == "$outemailacct"@"$outemaildomain"."$outtopdomain" ]] || [[ -z "$outemaildomain" ]] || [[ -z "$outtopdomain" ]];then
                  printf "\nEmail address not in correct format.  Re-enter it...\033[1A\r$scratchpad";horizptr="${#scratchpad}"
                  continue
              fi
          ! [[ -z "$outemailadd" ]] && break
# echo;printf "Addresses are\n\n${toemailadds:: -2}"
printf "In the email that will inform those recipients who you specified of the new IP\
\naddress listed as one or a series of link[s] formatted as any browser would\
\naccept in the address bar, enter the protocol, subdirectories and options, and\
\nport that the address will begin and end with, in as many combinations as you'd\
\nlike displayed in the email.\
\nExample: Suppose your computer serves two web pages, one as http and the other\
\nas https, two camera video streams, wifi modem administration, ssh, and a remote\
\ncontrol channel, so you could want all 7 links sent in the new IP address\
\nnotification email, along with reminder links of those 7 services with their\
\ninside (private) IP addresses for access to them when you are home, like this,\
\nsome port numbers fictitious:\
\n\nhttp://<new IP address>/sub/dir[s]:80\
\nhttps://<new IP address>/sub/dir[s]:443\
\nrtsp://<new IP address>/sub/dir[s] and options:15541\
\nrtsp://<new IP address>/sub/dir[s] and options:15542\
\nhttp://<new IP address>/sub/dir[s]:801\
\nssh homeowner@<new IP address>:122\
\nxmpp://<new IP address>/sub/dir[s] and options:121\
\n"
(cat <<EOF
#!/bin/bash
# arg 1 is file name of modified file in same directory as leases
# verify ending type is lease or leases
# then parse backwards making sure no private ip range is referenced
! [[ "\${1##*.}" == "lease" ]] && ! [[ "\${1##*.}" == "leases" ]] && ! [[ "\$1" =~ /etc/dhcpc/dhcpcd*.info ]] && ! [[ \"$1" =~ /usr/share/udhcpc/default.script ]] && ! [[ -z "$1" ]] && exit
#site-specific variables:
webpageprotocol=https
emailsubjectline="New IP address for $pcname: "
file_to_store_ip="$directoryforscripts/oldip"
resolver="dig +short myip.opendns.com @resolver1.opendns.com"
ip_from_resolver="\$(\$resolver)"
if [[ \$ip_from_resolver =~ ^((1?[0-9]?[0-9]|2[0-4][0-9]|25[0-5])\\.){3}(1?[0-9]?[0-9]|2[0-4][0-9]|25[0-5])\$ ]];
then
    if ( [ -f \$file_to_store_ip ] );
    then
        if [[ \$(< \$file_to_store_ip) =~ ^((1?[0-9]?[0-9]|2[0-4][0-9]|25[0-5])\\.){3}(1?[0-9]?[0-9]|2[0-4][0-9]|25[0-5])\$ ]] && [[ \$ip_from_resolver == \$(< \$file_to_store_ip) ]];
        then
echo "IP address is <\$ip_from_resolver> and not new, old ip = <\$(< \$file_to_store_ip)>"
            exit
        fi
    else
        : #first run
    fi
else
echo "IP address is <\$ip_from_resolver> and not acceptable"
    exit
fi
#fill in the here-doc section below to produce your desired email notification
(cat <<EOM
$webpageprotocol://$ip_from_resolver
\$($iptablespath -wnL PREROUTING -t nat|awk '{if (\$1=="DNAT") {for (i=6;i<=NF;i++) if (\$i ~ "^dport") {printf $(i+1)} else if (\$i ~ "^dpt") {printf substr(\$i,5,length(\$i)-4)}}print ""}')
ssh user@\$ip_from_resolver\
hping3 -V -S -c 1 -n -p port_number[s]  \$ip_from_resolver\
#adjust the protocol to the targeted service
http://$ip_from_internal_interface+1\
ssh user@\$ip_from_internal_interface\
EOM
) | mail -s "\$emailsubjectline" \$emaildestination

echo \$ip_from_resolver > \$file_to_store_ip
echo "IP address is <\$ip_from_resolver>"
EOF
) > "$directoryforscripts/newdynip.sh"

#  Only need to confirm if there are entries in crontab
! [[ "$(eval $crontabpath -l|$greppath -E -v ^#|$greppath -v ^[[:space:]]*$|$wcpath -l)" == "0" ]] && \
     (printf "$(eval $crontabpath -l|$greppath -E -v ^#|$greppath -v ^[[:space:]]*$|$wcpath -l) entries in crontab:\n\n$(eval "$crontabpath -l|$greppath -E -v ^#|$greppath -v ^[[:space:]]*$")\n"
      echo "Confirm you understand that your crontab shell is now getting changed which"
      read -n1 -s -p "might affect the above entries if they send values on, contain quotes, etc.: ")
(cat << CRONTAB_ENTRIES_END
$($crontabpath -l)
# line below is from poofitee_DynAddChangeNotify
@reboot "$directoryforscripts/newdynip.sh" >/dev/null 2>&1
##The following lines are from poofitee_DynAddChangeNotify and intentionally redundant to allow owner/sysadmin to change dhcp client package and still get notified of dhcp change
@reboot $nicepath -n19 $inotifywaitpath --format %w%f --quiet --monitor --event modify /var/lib/dhcp/dhclient.$external_net_interface.leases|while read filename;do "$directoryforscripts/newdynip.sh" "\$filename";done >/dev/null 2>&1
@reboot $nicepath -n19 $inotifywaitpath --format %w%f --quiet --monitor --event modify /etc/dhcpc/|while read filename;do "$directoryforscripts/newdynip.sh" "\$filename";done >/dev/null 2>&1 # dhcpcd*.info        DO MONITOR, make separate entry for each file found
@reboot $nicepath -n19 $inotifywaitpath --format %w%f --quiet --monitor --event access /usr/share/udhcpc/default.script|while read filename;do "$directoryforscripts/newdynip.sh";done >/dev/null 2>&1 # NEED TO INOTIFYWAIT MONITOR FOR "ACCESS" THE SCRIPT FILE THAT GETS EXECUTED ON CHANGE
@reboot $nicepath -n19 $inotifywaitpath --format %w%f --quiet --monitor --event modify /var/db/|while read filename;do "$directoryforscripts/newdynip.sh" "\$filename";done >/dev/null 2>&1 # *lease*
@reboot $nicepath -n19 $inotifywaitpath --format %w%f --quiet --monitor --event modify /var/lib/dhcp/|while read filename;do "$directoryforscripts/newdynip.sh" "\$filename";done >/dev/null 2>&1 # dhclient*.lease*
@reboot $nicepath -n19 $inotifywaitpath --format %w%f --quiet --monitor --event modify /var/lib/dhcp/|while read filename;do "$directoryforscripts/newdynip.sh" "\$filename";done >/dev/null 2>&1 # *.lease*
@reboot $nicepath -n19 $inotifywaitpath --format %w%f --quiet --monitor --event modify /var/lib/dhcpd/|while read filename;do "$directoryforscripts/newdynip.sh" "\$filename";done >/dev/null 2>&1 # dhcpd.lease*
@reboot $nicepath -n19 $inotifywaitpath --format %w%f --quiet --monitor --event modify /var/lib/dhcp3/|while read filename;do "$directoryforscripts/newdynip.sh" "\$filename";done >/dev/null 2>&1 # *.lease*
@reboot $nicepath -n19 $inotifywaitpath --format %w%f --quiet --monitor --event modify /var/lib/dhcp3/|while read filename;do "$directoryforscripts/newdynip.sh" "\$filename";done >/dev/null 2>&1 # dhclient*.lease*
@reboot $nicepath -n19 $inotifywaitpath --format %w%f --quiet --monitor --event modify /var/lib/dhcp3/|while read filename;do "$directoryforscripts/newdynip.sh" "\$filename";done >/dev/null 2>&1 # *.lease*
@reboot $nicepath -n19 $inotifywaitpath --format %w%f --quiet --monitor --event modify /var/lib/dhcpcd/|while read filename;do "$directoryforscripts/newdynip.sh" "\$filename";done >/dev/null 2>&1 # *.*
@reboot $nicepath -n19 $inotifywaitpath --format %w%f --quiet --monitor --event modify /var/lib/dhclient/|while read filename;do "$directoryforscripts/newdynip.sh" "\$filename";done >/dev/null 2>&1 # *.lease*
@reboot $nicepath -n19 $inotifywaitpath --format %w%f --quiet --monitor --event modify /var/lib/misc/|while read filename;do "$directoryforscripts/newdynip.sh" "\$filename";done >/dev/null 2>&1 # udhcpc*.lease*
@reboot $nicepath -n19 $inotifywaitpath --format %w%f --quiet --monitor --event modify /var/lib/NetworkManager/|while read filename;do "$directoryforscripts/newdynip.sh" "\$filename";done >/dev/null 2>&1 # *.lease*
CRONTAB_ENTRIES_END
) |$crontabpath -
[[ "$(eval "$crontabpath -l|$greppath -c \"SHELL=\"")" == "0" ]] && \
  printf "SHELL=/bin/bash\n$($crontabpath -l)"|$crontabpath - || \
  eval "$crontabpath -l|$sedpath \"/SHELL=/c\SHELL=/bin/bash\"|$crontabpath -"
echo "crontab set up..."
}

outemail_warnings () {
         printf "This installation script is about to make changes to this computer that can\
\nprofoundly change the way it SENDS OUT email.  No accommodation will be given\
\nfor any email sending capability that you might already have set up.  PLEASE do\
\nNOT expect this scripting to give any OUTBOUND emailing consideration for email\
\nprograms you have previously installed.  Only proceed if you agree with this\
\nnotion.  In contrast, INBOUND emailing is not expected to be affected because\
\nthis scripting does not rely on, nor change the settings of, any email client\
\nprogram for inbound email."
}

end_warnings () {
         printf "Remember always this fact of life:  Email providers do make unpredictable\
\nchanges to their email service!  The same holds true for ISPs.  Blame that any\
\nnumber of different reasons...technical, social, and otherwise.  Be aware that\
\nthe settings you just created may need to be adjusted in the future in response\timeou
\nto changes that others WILL make to affect your Internet experience, even\
\nchanges expressly designed to limit the usefulness of this fine enhancement\
\nyou've made to your Internet connectivity!  Though let's hope they'll have\
\nbetter reason for doing so than that."
}
get_1_addr_from_bunch() {
#one arg: a bunch of newline delimited email addresses
          emailadds="$1"
          scratchpad="${emailadds%%'\n'*}"
          emailaddid=1 ;horizptr="${#scratchpad}"
          printf "(up/down-arrows will select, or edit into an entirely different account name)\n$scratchpad"
          while true;do #this loop get a new email account or one chosen from bunch with password
              while IFS= read  -rsn1 char;do
                   if [[ "$(printf "%d" "'$char")" == "27" ]];then # '
                         char1="";char2="";char3=""
                         read -rst 0.001 -n1 char1
                         read -rst 0.001 -n1 char2
                         read -rst 0.001 -n1 char3
                         if [[ "$char1$char2$char3" == "[A" ]] || [[ "$char1$char2$char3" == "[B" ]];then
                              if [[ "$char1$char2$char3" == "[A" ]];then
                                   emailaddid=$(( $emailaddid - 1 ))
                              else
                                   emailaddid=$(( $emailaddid + 1 ))
                              fi
                              if [[ $(( $emailaddid )) -lt 1 ]];then
                                    emailaddid=$(( $emailaddid + 1 ))
                                    continue
                              fi
                              scratchpad="$emailadds"
                              for i in `seq 2 $(( $emailaddid ))`;do
                                   ! [[ -z "${scratchpad#*'\n'}" ]] \
                                       && scratchpad="${scratchpad#*'\n'}" \
                                       || emailaddid=$(( $emailaddid - 1 ))
                              done
                              scratchpad="${scratchpad%%'\n'*}"
                              printf "\r${scratchpad}\033[K"
                              horizptr="$(( ${#scratchpad} ))"
                         elif [[ "$char1$char2$char3" == "[C" ]];then
                              if [[ $(( ${horizptr} )) -lt $(( ${#scratchpad} )) ]];then
                                    horizptr="$(( ${horizptr} + 1 ))"
                                    printf "\033[1C"
                              fi
                         elif [[ "$char1$char2$char3" == "[D" ]];then
                              if [[ $(( ${horizptr} )) -gt 0 ]];then
                                    horizptr="$(( ${horizptr} - 1 ))"
                                    printf "\033[1D"
                              fi
                         elif [[ "$char1$char2$char3" == "OF" ]];then
                              horizptr="$(( ${#scratchpad} ))"
                              printf "\r\033[${#scratchpad}C"
                         elif [[ "$char1$char2$char3" == "OH" ]];then
                              horizptr="0"
                              printf "\r"
                         elif [[ "$char1$char2$char3" == "[3~" ]];then
                              if [[ $(( ${horizptr} )) -lt $(( ${#scratchpad} )) ]];then
                                   scratchpad="${scratchpad:0:horizptr}${scratchpad:horizptr+1}" # handles the delete character
                                   printf "${scratchpad:horizptr}\033[K\r${scratchpad:0:horizptr}"
                              fi
                         fi
                   elif [[ "$(printf "%d" "'$char")" == "127" ]];then # '
                     if ! [[ $(( ${horizptr} )) -eq 0 ]];then # exit
                         horizptr="$(( ${horizptr} - 1 ))"
                         scratchpad="${scratchpad:0:horizptr}${scratchpad:horizptr+1}" # handles the backspace character
                         printf "\033[1D${scratchpad:horizptr}\033[K\r${scratchpad:0:horizptr}"
                     fi
                   elif [[ -z "$char" ]];then
                         break
                   else
                        horizptr="$(( ${horizptr} + 1 ))"
                        scratchpad="${scratchpad:0:horizptr-1}$char${scratchpad:horizptr-1}"
                        printf "$char${scratchpad:horizptr}\033[K\r${scratchpad:0:horizptr}"
                   fi
              done
              emailadd="${scratchpad%%'\n'*}"
# printf  "\n\nSelected address is $emailadd\n"
              emailacct="${emailadd%@*}";emailprovider="${emailadd#*@}"
              emaildomain="${emailprovider%.*}"
              topdomain="${emailprovider##*.}"
              if ! [[ "$emailadd" =~ ^(([-a-zA-Z0-9\!#\$%\&\'*+/=?^_\`{\|}~]+|(\"([][,:;<>\&@a-zA-Z0-9\!#\$%\&\'*+/=?^_\`{\|}~-]|(\\\\[\\ \"]))+\"))\.)*([-a-zA-Z0-9\!#\$%\&\'*+/=?^_\`{\|}~]+|(\"([][,:;<>\&@a-zA-Z0-9\!#\$%\&\'*+/=?^_\`{\|}~-]|(\\\\[\\ \"]))+\"))+@[A-Za-z0-9.-]+\.[A-Za-z]{2,4}$ ]];then
                  printf "\nEmail address not in correct format.  Re-enter it...\033[1A\r$scratchpad";horizptr="${#scratchpad}"
                  continue
              fi
              printf "\n\033[K"
              emailpw1="";emailpw=""
              until [[ "$emailpw1" == "$emailpw" ]] && ! [[ -z "$emailpw1""$emailpw" ]];do
                  read -s -p "Password for account $emailadd: " emailpw1
                  [[ -z "$emailpw1" ]] && exit || echo
                  read -s -p "Re-type same password: " emailpw
                  if ! [[ "$emailpw1" == "$emailpw" ]];then
                      printf "\nPassword not entered consistently."
                  else
                      echo
                  fi
              done
          ! [[ -z $emailadd ]] && ! [[ -z "$emailpw" ]] && break
          done
}

printf "POOFITEE is currently available in experimental status.  Your suggestions for\
\nimprovements are solicited and welcome ... press a key to continue"
read -rsn 1;read -rst 0.001 -n3
usrdir="";localdir="";sharedir="";bindir="";sbindir="";binaryflag="-b";dirsign="";counter=0
D2b=({0..1}{0..1}{0..1}{0..1}{0..1}{0..1})
until whereispath="$usrdir$localdir$sharedir$bindir$sbindir$dirsign""whereis";[[ ++counter -eq 64 ]] || [[ "$($whereispath $binaryflag whereis &> /dev/null;echo $?)" == "0" ]];do
    ! [[ -z "$binaryflag" ]] && binaryflag="" && continue
    binaryflag="-b"
    dirsign="/"
    usrdir="";localdir="";sharedir="";bindir="";sbindir=""
    cntr="${D2b[counter]}"
    [[ "$cntr" =~ ^1 ]] && usrdir="/usr"
    [[ "$cntr" =~ ^.1 ]] && localdir="/local"
    [[ "$cntr" =~ ^..1 ]] && sharedir="/share"
    [[ "$cntr" =~ ^...1 ]] && bindir="/bin"
    [[ "$cntr" =~ ^....1 ]] && sbindir="/sbin"
done
if [[ counter -eq 64 ]];then echo "Unable to locate executable files on your system";exit;fi
whereispath="${whereispath#*:}";whereispath="${whereispath# }";whereispath="${whereispath%% *}"
unamepath="$($whereispath $binaryflag uname)"
unamepath="${unamepath#*:}";unamepath="${unamepath# }";unamepath="${unamepath%% *}"
sortpath="$($whereispath $binaryflag sort)"
sortpath="${sortpath#*:}";sortpath="${sortpath# }";sortpath="${sortpath%% *}"
headpath="$($whereispath $binaryflag head)"
headpath="${headpath#*:}";headpath="${headpath# }";headpath="${headpath%% *}"
exitmsg="Thank you for running this POOFITEE configuration script...God loves you pass it on"
min_bash_version_tested="4.3.11";! [[ "$($sortpath <<<"$(printf "$BASH_VERSION\n$min_bash_version_tested")"|$headpath -n 1)" == "$min_bash_version_tested" ]] && \
   trap "echo If you had run-time errors, your version of bash might be too old. $exitmsg" EXIT || \
   trap "echo $exitmsg" EXIT
if [[ "$($unamepath)" =~ BSD ]] || [[ "$($unamepath)" =~ Darwin ]];then printf "This firewalling solution does not accommodate Mac nor BSD due to"\
"\niptables and crontab dysfunction in those *NIXes";exit;fi
if ! [ "$(whoami)" == "root" ];then printf "\nWithout being launched by su, this script\
 won't be able to do anything except\
\ndisplay menus.  No control of this computer can be made by this script unless\
\nre-launched by root.  Press a key to acknowledge, Ctrl-c to abort\n";read -rsn 1;read -rst 0.001 -n3;fi
#  Beginning of copyright message
printf "\nCopyright 2016 - Kenneth L. Anderson MCSE, RDH, BGS, BT\
\n\nThis work of authorship is made available to you under only one out of the\
\nfollowing two arrangements.  In both arrangements, this copyright message must\
\nremain with this work of authorship and any and all of its derivatives.\
\n\n1.  Arrangement for your freedom from monetary obligation to the author:\
\n - This copyright message must continue to be displayed at launch time\
\n - This copyright message includes the statement\
\n\n\"       Jesus Christ is Lord of all  ... press a key to acknowledge\"\
\n\ndisplayed on its own line with blank lines adjacently both above and below\
\nsaid nstatement and rendered statically without attempt made to render said\
\nstatement transiently.\
\n\n2.  Arrangement for your freedom from copyright display obligation, or to\
\ncontribute, see the comments within the source code of this script"
printf "\n\n       Jesus Christ is Lord of all  ... press a key to acknowledge\n"
read -rsn 1;read -rst 0.001 -n3
awkpath="$($whereispath $binaryflag awk)" # some occurances removed due to inconsistencies with macs
awkpath="${awkpath#*:}";awkpath="${awkpath# }";awkpath="${awkpath%% *}"
pythonpath="$($whereispath $binaryflag python)"
pythonpath="${pythonpath#*:}";pythonpath="${pythonpath# }";pythonpath="${pythonpath%% *}"
greppath="$($whereispath $binaryflag grep)"
greppath="${greppath#*:}";greppath="${greppath# }";greppath="${greppath%% *}"
ifconfigpath="$($whereispath $binaryflag ifconfig)"
ifconfigpath="${ifconfigpath#*:}";ifconfigpath="${ifconfigpath# }";ifconfigpath="${ifconfigpath%% *}"
pumppath="$($whereispath $binaryflag pump)"
pumppath="${pumppath#*:}";pumppath="${pumppath# }";pumppath="${pumppath%% *}"
uniqpath="$($whereispath $binaryflag uniq)"
uniqpath="${uniqpath#*:}";uniqpath="${uniqpath# }";uniqpath="${uniqpath%% *}"
findpath="$($whereispath $binaryflag find)"
findpath="${findpath#*:}";findpath="${findpath# }";findpath="${findpath%% *}";
tailpath="$($whereispath $binaryflag tail)"
tailpath="${tailpath#*:}";tailpath="${tailpath# }";tailpath="${tailpath%% *}"
xargspath="$($whereispath $binaryflag xargs)"
xargspath="${xargspath#*:}";xargspath="${xargspath# }";xargspath="${xargspath%% *}"
sedpath="$($whereispath $binaryflag sed)"
sedpath="${sedpath#*:}";sedpath="${sedpath# }";sedpath="${sedpath%% *}"
wcpath="$($whereispath $binaryflag wc)";wcpath="${wcpath#*:}";wcpath="${wcpath# }";wcpath="${wcpath%% *}"
ippath="$($whereispath $binaryflag ip)" # Macs don't have the ip command at this time
ippath="${ippath#*:}";ippath="${ippath# }";ippath="${ippath%% *}"
pspath=$($whereispath $binaryflag ps);pspath="${pspath#*:}";pspath="${pspath# }";pspath="${pspath%% *}"
# dhcp_lease_path=$($findpath / -maxdepth 5 -name dhclient*.lease* 2> /dev/null)
rhel="$($whereispath $binaryflag chkconfig)"
rhel="${rhel#*:}";rhel="${rhel# }";rhel="${rhel%% *}"
eval "$pythonpath -c \"import platform;print(platform.linux_distribution()[0])\" &> /dev/null > \"distributionby.${0#*/}\"" \
    || eval "printf \"Functionality may be limited due to inability to determine distribution type\n...press a key to continue...\";read -rsn1;read -rst 0.001 -n3" \
    || eval "echo $OSTYPE > \"distributionby.${0#*/}\""
# eval "$ifconfigpath -a|$awkpath -F'^ ' '{print \$1}'|$awkpath '{print \$1}'|$greppath -vw lo|$xargspath" > "interfacesby.${0#*/}"
external_net_interface="$($ippath -o route get 8.8.8.8|$awkpath '{ print $5 }')"
# printf "\n\ninterface going to google=$external_net_interface"
internal_net_interface="$($ippath link show|$greppath -E "^[1-9][0-9]*:"|$greppath -v lo:\
    |$greppath -v "$external_net_interface"\
    |$sedpath 's/://g'\
    |$awkpath '{print $2}')"
# echo "$( [[ $(printf "$internal_net_interface"|$wcpath -l) == "1" ]] \
#    && echo "$(printf "$internal_net_interface"|$wcpath -l) interface" \
#    || echo "$(printf "$internal_net_interface"|$wcpath -l) interfaces") not going to google=$internal_net_interface"
# echo "Script-required items: whereis path=$whereispath, awk path=$awkpath, python path=$pythonpath, grep path=$greppath, ifconfig path=$ifconfigpath, uniq path=$uniqpath, sort path=$sortpath, head path=$headpath";exit
#
# Introduction and what we'll do
startscreen="\nPOOFITEE\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`Main Configuration Screen\
\n                SELECT DESIRED OPTIONS FOR THIS INSTALLATION\
\n\n\n      (f) firewalling\
\n\n      (e) email remote control\
\n\n      (d) dynamic IP address change notifier"
if [[ $($pspath aux|$greppath -vw grep|$greppath -we pump -we dhclient -we udhcpc -we dhcpcd -we dhclient3|$greppath -w $external_net_interface|$wcpath -l) -eq 0 ]];then
     startscreen+=" NOT for your configuration";notdhcp="notdhcp"
fi
startscreen+="\n\n      (p) port knocking\
\n\n      (s) save configuration\
\n\n      (r) restore the previously saved configuration\
\n\n      (?) context helpful information\
\n\n
\nTyping the letters f, e, d, p, s, r optionally followed by a question mark, or\
\njust plain ? with no letters, select all of the five services listed above that\
\nyou want, then press ENTER: (or Ctrl-c at any time to terminate installer)\n"
# POOFITEE: "Perfect Owner Only access linux Firewall - the system is Invisible To Everyone Else"
ghscreen1="POOFITEE\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`Information Screen\
\n                              Helper Script Overview\
\nThis set of Linux scripts can install several Internet security features useful\
\nin homeowner and enterprise systems alike. Enterprise systems however, typically\
\nare stranger-visible, while the POOFITEE ruleset is stranger-INvisible.  Gone\
\nare the complex, buggy \"badguy detection\" algorithms of other firewalls.  More\
\nunique still to POOFITEE is that the only continuously-running process it has is\
\na \"tail -f\" bash script line monitoring kernel log events for the purpose of\
\nlaunching a script.  So POOFITEE is a firewall-plus paradigm, not a running\
\nprogram.  For a similar reason, it is not an iptables front-end and does not\
\ninterfere with manual iptables manipluation, allowing you to fine-tune the rule-\
\nset yourself.  Only trusted addresses can initiate a dialog under the POOFITEE\
\nruleset.  Of course, those source addresses can be spoofed, but when spoofed, a\
\ntwo-way connection capable of stealing information is not really possible: the\
\nlegitimate computer owning the spoofed trusted address will receive return\
\ncommunications and, without a reason to be in collusion with the spoofer, not\
\nrelay the information on to them.  The name \"POOFITEE\" is derived from the\
\ndescriptive phrase \"almost Perfect Owner Only access linux Firewall - the system\
\nis Invisible To Everyone Else\".  \"Almost\", you protest?  That is because\
\nhackers commonly use deceitful email to convince the unsuspecting operator of a\
\ntrusted computer to execute malicious email links.  POOFITEE does not block such\
\ncommunications that are initiated by trusted computer addresses like that, but\
\nagain, POOFITEE will allow you to improve the iptables rules manually, if you\
\nare so inspired..."
ghscreen2="POOFITEE\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`Information Screen\
\n\nThe advantages of using scripting over a compiled program are significant:\
\n - most importantly - robust operation in indefinitely continuous duty\
\n - less script complexity means less risk of programming bugs and mysterious,\
\n      hard-to-troubleshoot resource limitations\
\n - source code is simple and extremely easy for you to customize to your liking\
\n - iptables rule changes are implemented instantly without any process restarts\
\n      nor conflicts with iptables rules manipulated manually\
\n - system operators can customize the behavior of all aspects of POOFITEE\
\n      support scripts without learning to compile, and those customizations are\
\n      implemented instantly.\
\n\nThe disadvantages of scripting to compiled languages are normally considered\
\nto be execution speed of the finished program and fine control of low-level\
\nsystem functionalities.  POOFITEE is not practically affected by either, thanks\
\nto the power that Linux scripting offers."
fwscreen="POOFITEE\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`Information Screen\
\n                        FIREWALLING WITH THIS SCRIPT SET\
\n( As you read, please realize the difference between this installation \"helper\
\nscript\" that you are running now and the \"script set\" it helps you install )\
\n\nTo configure firewalling, port-knocking, or email remote control, iptables &\
\nnetfilter-persistent are required if not already present.  These are standard\
\nfor any Linux firewalling.  As far as manual control of iptables during run\
\ntime, POOFITEE plays fair.  It will simply configure iptables - an\
\ninitial configuration by the helper script, then periodic configurations of\
\niptables throughout the course of normal operations by the installed script set.\
\nUnlike what exists with ufw, shorewall, and fail2ban, no ongoing integration\
\nwith iptables will exist to interfere at any time with direct user adjustment of\
\nthe iptables ruleset.\
\nFirewalling options this install script can alter from the script set defaults:\
\n  -- Stop probe logging/blacklisting to save space or if you're just not curious\
\n  -- Open specific ports to offer public services\
\n  -- Force single-interface firewalling even though two interfaces exist\
\n  -- Alter the IP address of the private-side interface from 192.168.3.1\
\n\n* No testing has been done using DHCP client nor server on the private interface"
rcscreen="POOFITEE\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`Information Screen\
\n                  REMOTE CONTROL VIA EMAIL WITH THIS SCRIPT SET\
\n( As you read, please realize the difference between this installation \"helper\
\nscript\" that you are running now and the \"script set\" it helps you install )\
\n\nWhat we mean by Remote Control Via Email:  You find yourself travelling far away\
\nfrom home, and thus, far away from this computer you are configuring.  You\
\ndecide you need this computer to do a few things for you now before you return.\
\nOne is to turn on and off one of the electrical outlets that it controls through\
\na USB-connected Arduino board.  You also remember that there is an old iptables\
\nrule whitelisting an IP address that belongs no longer belongs to you, so you\
\nneed your home system to remove it from the iptables whitelist.  This and more\
\nis possible if you just connect that Arduino you've built and run this script.\
\nThis helper script will need from you name and password of the email account\
\nthat this computer will retrieve the emails from that you send to it.  This\
\nhelper script will test its functionality and give you a choice of which port\
\nnumber you want to use (knock) to trigger your system to read and parse emails.\
\nIdeally, you would want to choose a port number that never gets probed by\
\nthe hackers of the world.  Logging probed ports (configured in the firewall\
\nsection of this helper script) would be a handy reference here.\
\n\n* No testing has been done using DHCP client nor server on the private interface"
dascreen="POOFITEE\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`Information Screen\
\n          EMAIL NOTIFY OF DYNAMIC IP ADDRESS CHANGE WITH THIS SCRIPT SET\
\n( As you read, please realize the difference between this installation \"helper\
\nscript\" that you are running now and the \"script set\" it helps you install )\
\n\nTo configure firewalling, port-knocking, or email remote control, iptables &\
\nnetfilter-persistent are required if not already present.  These are standard\
\nfor any Linux firewalling.  As far as manual control of iptables during run\
\ntime, this script set is friendly.  It will simply configure iptables - an\
\ninitial configuration by the helper script, then periodic configurations of\
\niptables throughout the course of normal operations by the installed script set.\
\nUnlike what exists with ufw, shorewall, and fail2ban, no ongoing integration\
\nwith iptables will exist to interfere at any time with direct user adjustment of\
\nthe iptables ruleset.\
\nFirewalling options this install script can alter from the script set defaults:\
\n  -- Stop probe logging/blacklisting to save space or if you're just not curious\
\n  -- Open specific ports to offer public services\
\n  -- Force single-interface firewalling even though two interfaces exist\
\n  -- Alter the IP address of the private-side interface from 192.168.3.1\
\n\n* No testing has been done using DHCP client nor server on the private interface"
pkscreen="POOFITEE\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`Information Screen\
\n                        PORT KNOCKING WITH THIS SCRIPT SET\
\n( As you read, please realize the difference between this installation \"helper\
\nscript\" that you are running now and the \"script set\" it helps you install )\
\n\nTo configure firewalling, port-knocking, or email remote control, iptables &\
\nnetfilter-persistent are required if not already present.  These are standard\
\nfor any Linux firewalling.  As far as manual control of iptables during run\
\ntime, this script set is friendly.  It will simply configure iptables - an\
\ninitial configuration by the helper script, then periodic configurations of\
\niptables throughout the course of normal operations by the installed script set.\
\nUnlike what exists with ufw, shorewall, and fail2ban, no ongoing integration\
\nwith iptables will exist to interfere at any time with direct user adjustment of\
\nthe iptables ruleset.\
\nFirewalling options this install script can alter from the script set defaults:\
\n  -- Stop probe logging/blacklisting to save space or if you're just not curious\
\n  -- Open specific ports to offer public services\
\n  -- Force single-interface firewalling even though two interfaces exist\
\n  -- Alter the IP address of the private-side interface from 192.168.3.1\
\n\n* No testing has been done using DHCP client nor server on the private interface"
savescreen="POOFITEE\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`Information Screen\
\n                       SAVING YOUR INSTALLED CONFIGURATION\
\nSelecting this is only meaningful if one or more of the above selections is also\
\nselected or has previously been configured.  Saving the configuration with this\
\nchoice is a convenient way for you to replicate the configuration on other\
\nservers or prepare for an operating system upgrade on this one.  You'll be\
\ngiven a choice where to store the saved configuration, whether locally or on\
\nremoveable media or remotely."
restorescreen="POOFITEE\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`\`Information Screen\
\n                   RESTORING YOUR PREVIOUSLY SAVED CONFIGURATION\
\nThis is a convenient way to replicate the configuration on other servers or on\
\nthis one after an operating system upgrade without answering the setup questions\
\nall over again.  This can be highly important when you don't know for sure that\
\nthe person who needs to configure will know or remember the details of this\
\nconfiguration.  $internal_net_interface"
answer=""
singinterf="\nBased on finding only one pluggable network interface, your intentions seem\
\nto be to have this firewalling computer be a terminal (end) device rather than\
\nan inline (passthrough) device.  That would result in any protective\
\nfirewalling you'll set up next to apply only to this computer.  If instead you\
\nwant this firewalling computer to protect other devices with its firewalling\
\nservices, select"
postfix_already_conf=""
until ! [ -z $answer ];do
     clear
     printf "$startscreen"
# exit
########### remove answer and char set line below and uncomment out next line
#    while true;do answer="fdrp";char="";[[ -z "$char" ]] && break
     while IFS= read  -sn1 char;do [[ -z "$char" ]] && break
        [[ "$answer$char" == "?" ]] && break
        if [[ "$(printf "%d" "'$char")" == "27" ]];then # ' escape or extended key has been detected
            read -rt 0.001 -n1 discard # read 2nd extended key field, timeout if real escape
            [[ "$(printf "%d" "'$discard")" == "0" ]] && exit # '
            read -rt 0.001 -n2 discard # read & discard 2nd extended key field, timeout if no more
        elif [ "${answer%$char*}" == "$answer" ] && [[ "$char" =~ [frdpFRDP] ]];then
            char="${char,}"
            printf "$char"
            answer="$answer$char"
        elif [ "$char" == "?" ] && ! [ "${answer: -1}" == " " ];then
            printf "$char "
            answer="$answer$char "
        else
            [[ "$(printf "%d" "'$char")" == "127" ]] && ! [[ -z $answer ]] && answer="${answer:0: -1}" # ' handles the backspace character
            printf "\r$answer    \r$answer" # needed b/c when several keys are pressed simultaneously only first gets silented
        fi
     done
     if [ -z $answer$char ];then
        exit
     elif [[ $answer$char =~ \? ]];then
        clear;printf "Selections: $answer$char";printf "  Since info is selected, no changes are to be made"
        if [[ $answer$char == "?" ]];then
             clear
             printf "$ghscreen1"
             read -rsn1 -p "        Press a key to continue..."
             read -rst 0.001 -n3
             clear
             printf "$ghscreen2"
             read -rsn1 -p "   (Press key...)"
             read -rst 0.001 -n3
             echo
        fi
        [[ $answer =~ f ]] || [[ $answer$char == "?" ]] && (clear;printf "$fwscreen\n";read -rsn1 -p "                         Press a key to continue...";read -rst 0.001 -n3;echo)
        [[ $answer =~ e ]] || [[ $answer$char == "?" ]] && (clear;printf "$rcscreen\n";read -rsn1 -p "                         Press a key to continue...";read -rst 0.001 -n3;echo)
        [[ $answer =~ d ]] || [[ $answer$char == "?" ]] && (clear;printf "$dascreen\n";read -rsn1 -p "                         Press a key to continue...";read -rst 0.001 -n3;echo)
        [[ $answer =~ p ]] || [[ $answer$char == "?" ]] && (clear;printf "$pkscreen\n";read -rsn1 -p "                         Press a key to continue...";read -rst 0.001 -n3;echo)
        [[ $answer =~ s ]] || [[ $answer$char == "?" ]] && (clear;printf "$savescreen\n";read -rsn1 -p "                         Press a key to continue...";read -rst 0.001 -n3;echo)
        [[ $answer =~ r ]] || [[ $answer$char == "?" ]] && (clear;printf "$restorescreen\n";read -rsn1 -p "                         Press a key to continue...";read -rst 0.001 -n3;echo)
        answer=""
     else
         echo
         until false;do  # this loop is to set path vars after pkgs get installed, every last pkg so paths populate even after new installs
            until [ "$goahead" == "true" ];do
                  installers=(apt-get "install --fix-missing" dnf install yum install zypper install emerge "" pacman -S pkg install pkg_add "" xbps-install -Sy brew install port install)
                  for installer in {0..10};do
                      installerpath=$($whereispath $binaryflag ${installers[$(($installer * 2))]});installerpath="${installerpath#*:}";installerpath="${installerpath# }";installerpath="${installerpath%% *}"
                      [[ -z "$installerpath" ]] && continue
                      installerpath+="  ${installers[$(($installer * 2 + 1))]}"
                      break
                  done
#  packages required to install everything
                  inotifywaitpath=$($whereispath $binaryflag inotifywait);inotifywaitpath="${inotifywaitpath#*:}";inotifywaitpath="${inotifywaitpath# }";inotifywaitpath="${inotifywaitpath%% *}"
                  iptablespath=$($whereispath $binaryflag iptables);iptablespath="${iptablespath#*:}";iptablespath="${iptablespath# }";iptablespath="${iptablespath%% *}"
# TODO: the next line is very, very version dependent
                  iptabperspath=$($findpath / -maxdepth 3 -name *persistent|$greppath -vw doc|$greppath -vw src|$greppath -vw sys|$greppath -e iptables -e netfilter|$greppath -m 1 -e init.d 2> /dev/null)
                  stdbufpath=$($whereispath $binaryflag stdbuf);stdbufpath="${stdbufpath#*:}";stdbufpath="${stdbufpath# }";stdbufpath="${stdbufpath%% *}"
                  crontabpath=$($whereispath $binaryflag crontab);crontabpath="${crontabpath#*:}";crontabpath="${crontabpath# }";crontabpath="${crontabpath%% *}"
                  sleeppath=$($whereispath $binaryflag sleep);sleeppath="${sleeppath#*:}";sleeppath="${sleeppath# }";sleeppath="${sleeppath%% *}"
                  ifdownpath=$($whereispath $binaryflag ifdown);ifdownpath="${ifdownpath#*:}";ifdownpath="${ifdownpath# }";ifdownpath="${ifdownpath%% *}"
                  ifuppath=$($whereispath $binaryflag ifup);ifuppath="${ifuppath#*:}";ifuppath="${ifuppath# }";ifuppath="${ifuppath%% *}"
                  datepath=$($whereispath $binaryflag date);datepath="${datepath#*:}";datepath="${datepath# }";datepath="${datepath%% *}"
                  bcpath=$($whereispath $binaryflag bc);bcpath="${bcpath#*:}";bcpath="${bcpath# }";bcpath="${bcpath%% *}"
                  wcpath=$($whereispath $binaryflag wc);wcpath="${wcpath#*:}";wcpath="${wcpath# }";wcpath="${wcpath%% *}"
                  atpath=$($whereispath $binaryflag at);atpath="${atpath#*:}";atpath="${atpath# }";atpath="${atpath%% *}";! [[ "${atpath: -2:2}" == "at" ]] && atpath=""
                  nicepath=$($whereispath $binaryflag nice);nicepath="${nicepath#*:}";nicepath="${nicepath# }";nicepath="${nicepath%% *}"
                  mailpath=$($whereispath $binaryflag mail);mailpath="${mailpath#*:}"
                  [[ -z "$mailpath" ]] && mailpath=" $($whereispath $binaryflag mailx)";mailpath="${mailpath#*:}"
                  [[ -z "$mailpath" ]] && mailpath=" $($whereispath $binaryflag sendmail)";mailpath="${mailpath#*:}"
                  mailpath="${mailpath# }";mailpath="${mailpath%% *}"
                  postmappath=$($whereispath $binaryflag postmap);postmappath="${postmappath#*:}";postmappath="${postmappath# }";postmappath="${postmappath%% *}"
                  postqueuepath=$($whereispath $binaryflag postqueue);postqueuepath="${postqueuepath#*:}";postqueuepath="${postqueuepath# }";postqueuepath="${postqueuepath%% *}"
                  sendmail_works=""
                  if ! [[ -z $mailpath ]];then
                       mailadd=""
                       mailcmd="echo $0 \"test.  Press y\"|$mailpath"
                       printf "\nOne aspect of an option you selected will be to send you alert notices to your\
\nemail account.  For emailing alerts to you, specialized configuration is\
\nrequired so this computer can send emails from the command line.  We'll send a\
\ntest email now to see if it can send from the command line already if you'll\
\nplease enter an email address to finish the following mail command, choosing an\
\naddress that you can immediately receive a test email through and verify\
\nreception of it on a different computing device:\n"
newemailconfigwarning="Installing a new configuration is\
\ndefinitely NOT what you want if this computer is already or will be in use in a\
\nbusiness email service role, like MTA, MDA, email relay, or email server because\
\nthe settings this installation script will change will most certainly be\
\nincompatible with said role.  If you need to avoid installing the emailing\
\nconfiguration, you should manually get the command line email sending to work\
\nwith whichever mail command is shown above, \"mail\", \"mailx\", or \"sendmail\" that\
\nthis scripting has found to currently exist on your system."
                       until false;do
                            ! [[ -z "$mailadd" ]] && printf "That doesn't appear to be a valid email address.  Try again or remove it to skip\
\nthis test and install a full, new configuration on this computer\
\nfor sending emails from the command line.  $newemailconfigwarning"
                            echo
                            get_sendto_emailadds onlyneed1
                            read -e -r -i "$mailadd" -p "$mailcmd " mailadd
                            if [[ -z "$mailadd" ]]; then break;fi
                            if ! [[ "$mailadd" =~ ^(([-a-zA-Z0-9\!#\$%\&\'*+/=?^_\`{\|}~]+|(\"([][,:;<>\&@a-zA-Z0-9\!#\$%\&\'*+/=?^_\`{\|}~-]|(\\\\[\\ \"]))+\"))\.)*([-a-zA-Z0-9\!#\$%\&\'*+/=?^_\`{\|}~]+|(\"([][,:;<>\&@a-zA-Z0-9\!#\$%\&\'*+/=?^_\`{\|}~-]|(\\\\[\\ \"]))+\"))+@[A-Za-z0-9.-]+\.[A-Za-z]{2,4}$ ]];then
                                 continue
                            fi
                            if ! [[ -z "$mailadd" ]];then
                                 printf "Sending a test email to $mailadd..."
                                 eval "$mailcmd $mailadd"
                                 wait
                                 if [[ "$?" == "0" ]];then
                                      printf "\n\nDid the test email get sent and received? y/n/t/a (Yes, No, or Try Again): "
                                      read -r -n1
                                      if [[ $REPLY =~ y ]];then 
                                          sendmail_works=True
                                          echo
                                          break
                                      elif [[ $REPLY =~ [at] ]];then
                                          continue
                                      fi
                                 fi
                                 printf "\nThe email command appears to have failed.  This means a full, new email sending\
\nconfiguration will be set up on this computer. $newemailconfigwarning"
                                 printf "\nIf you are unsure this is what you want, press ctrl-c before continuing"
                                 sleep 2
                            fi
                       done
                  fi
                  notinstalled=""
                  if [[ $answer =~ f ]];then
                      [[ -z $inotifywaitpath ]] && notinstalled+="inotify-tools\n"
                      [[ -z $iptablespath ]] && notinstalled+="iptables\n"
                      [[ -z $iptabperspath ]] && notinstalled+="iptables-persistent\n"
                      [[ -z $stdbufpath ]] && notinstalled+="coreutils\n"
                      [[ -z $mailpath ]] && notinstalled+="mailutils\n"
                      [[ -z $crontabpath ]] && notinstalled+="cronie\nbcron\n"
                      [[ -z $datepath ]] && notinstalled+="coreutils\n"
                      [[ -z $bcpath ]] && notinstalled+="bc\n"
                      [[ -z $atpath ]] && notinstalled+="at\n"
                      [[ -z $nicepath ]] && notinstalled+="coreutils\n"
                      [[ -z $sendmail_works ]] && [[ -z $postmappath ]] && notinstalled+="postmap\n"
                  fi
                  if [[ $answer =~ e ]];then
                      [[ -z $inotifywaitpath ]] && notinstalled+="inotify-tools\n"
                      [[ -z $iptablespath ]] && notinstalled+="iptables\n"
                      [[ -z $iptabperspath ]] && notinstalled+="iptables-persistent\n"
                      [[ -z $stdbufpath ]] && notinstalled+="coreutils\n"
                      [[ -z $mailpath ]] && notinstalled+="mailutils\n"
                      [[ -z $crontabpath ]] && notinstalled+="cronie\nbcron\n"
                      [[ -z $datepath ]] && notinstalled+="coreutils\n"
                      [[ -z $bcpath ]] && notinstalled+="bc\n"
                      [[ -z $atpath ]] && notinstalled+="at\n"
                      [[ -z $nicepath ]] && notinstalled+="coreutils\n"
                      [[ -z $sendmail_works ]] && [[ -z $postmappath ]] && notinstalled+="postmap\n"
                  fi
                  if [[ $answer =~ d ]];then
                      [[ -z $inotifywaitpath ]] && notinstalled+="inotify-tools\n"
                      [[ -z $iptablespath ]] && notinstalled+="iptables\n"
                      [[ -z $iptabperspath ]] && notinstalled+="iptables-persistent\n"
                      [[ -z $stdbufpath ]] && notinstalled+="coreutils\n"
                      [[ -z $mailpath ]] && notinstalled+="mailutils\n"
                      [[ -z $crontabpath ]] && notinstalled+="cronie\nbcron\n"
                      [[ -z $datepath ]] && notinstalled+="coreutils\n"
                      [[ -z $bcpath ]] && notinstalled+="bc\n"
                      [[ -z $atpath ]] && notinstalled+="at\n"
                      [[ -z $nicepath ]] && notinstalled+="coreutils\n"
                      [[ -z $sendmail_works ]] && [[ -z $postmappath ]] && notinstalled+="postmap\n"
                  fi
                  if [[ $answer =~ p ]];then
                      [[ -z $inotifywaitpath ]] && notinstalled+="inotify-tools\n"
                      [[ -z $iptablespath ]] && notinstalled+="iptables\n"
                 [[ -z $iptabperspath ]] && notinstalled+="iptables-persistent\n"
                 [[ -z $stdbufpath ]] && notinstalled+="coreutils\n"
                 [[ -z $mailpath ]] && notinstalled+="mailutils\n"
                 [[ -z $crontabpath ]] && notinstalled+="cronie\nbcron\n"
                 [[ -z $datepath ]] && notinstalled+="coreutils\n"
                 [[ -z $bcpath ]] && notinstalled+="bc\n"
                 [[ -z $atpath ]] && notinstalled+="at\n"
                 [[ -z $nicepath ]] && notinstalled+="coreutils\n"
                 [[ -z $sendmail_works ]] && [[ -z $postmappath ]] && notinstalled+="postmap\n"
             fi
             [[ -z $notinstalled ]] && break 2
             notinstalled="$(printf "$notinstalled"|$sortpath|$uniqpath)"
             if ! [[ -z $notinstalled ]] && [[ -z $installerpath ]] && ! [[ "$ackd" == "true" ]];then
                  printf "\n                  UNABLE TO INSTALL ANY PROGRAMS ON YOUR SYSTEM\
\n\nThis helper script version is not advanced enough to install needed programs on\
\nsystems such as yours that don't use a common installer to install programs.\
\nFor this install script to serve its purpose for you, you'll need to install all\
\nnecessary programs yourself before anything referenced hereafter can succeed.\
\nConsider yourself lucky if this script does anything at all for you beyond this\
\npoint, but do understand that the programs most certainly won't get installed.\
\n\nThe necessary programs that won't get installed until you install them are:\
\n$notinstalled\
\n\nYou may install them in another terminal and resume here, or press Ctrl-c to\
\nterminate here, or press any other key to proceed as-is\
\n\n     Acknowledge by keypress..."
                  read -rsn 1;read -rst 0.001 -n3;ackd="true"
             else
                  goahead="true"
             fi
        done # this loops here once when installer pgm not found
        clear
        if ! [[ -z "$installerpath" ]] && ! [[ -z "$notinstalled" ]];then # install what is needed
                  printf "Installation of\n$notinstalled\n\nwill begin after your keypress...";read -rsn 1;read -rst 0.001 -n3
#                  echo "Executing $installerpath $notinstalled"|$sedpath -e ':a' -e 'N' -e '$!ba' -e 's/\\n/ /g'
#change the next line to a loop if need be
                  printf "$notinstalled"|$sedpath -e ':a' -e 'N' -e '$!ba' -e 's/\\n/ /g'|sudo $xargspath sh -c 'exec "$installerpath $@" < /dev/tty' sh
      fi

        done  # this loop is to set path vars after pkgs get installed, every last pkg so paths populate even after new installs
       until false;do directoryforscripts="$( [[ -f directoryforscripts ]] && cat directoryforscripts || printf "/home/poofitee")"
            printf "\nSpecify the directory in which to install these scripts.  No deeper subdirectory\
\nwill be used than what you specify here, so include any final isolating or\
\ndescriptive subdirectory level you will want:\n"
            read -e -r -i "$directoryforscripts" directoryforscripts
            if ! [[ -d "$directoryforscripts" ]];then
                 echo
                 if [[ "$( read -n1 -p "Directory does not exist.  Create it? (y/n): " ans;echo "$ans" )" =~ [Yy] ]];then
                      mkdir -p "$directoryforscripts" && chmod 700 "$directoryforscripts"
                      mkdir -p "$directoryforscripts/preparedness" && chmod 700 "$directoryforscripts/preparedness"
                      [[ "$?" == "0" ]] && break
                      echo "Unable to use that path"
                 fi
            else
                 break
            fi
       done
       echo "$directoryforscripts" > directoryforscripts # handy with subsequent runs of this script, will know where everything is
       chmod 600 directoryforscripts
       directoryforscripts="${directoryforscripts%%/}"
       back_up_iptables_ruleset current && printf "\nIf you feel the changes that this script makes to your iptables ruleset are not\
\nwhat you wanted, restore the current ruleset by running\
\n\niptables-restore < $directoryforscripts/iptables_ruleset.$current_time\n\n" \
          || printf "Your current iptables ruleset did not get backed up as expected.  You should\
\npress ctl-c now and fix that, or you could be in a frustrating situation if\
\nsomething goes awry with this install.\n"
        if [[ "$answer" =~ f ]];then
#            echo "firewalling"
#             printf "iptables, including ruleset and crontab entries will be set up next.\
#\n   Press a key...";read -n1 -r
             install_buildiptablessh
             install_cronentries
             if [[ -z $sendmail_works ]];then
                  outemail_warnings
                  printf "\nPress a key to acknowledge and continue, Ctrl-c to abort..."
                  read -n1
             fi
             conf_postfix
        fi
        if [[ "$answer" =~ e ]];then
#             printf "remote controlling"
             install_rc
        fi
        if [[ "$answer" =~ d ]] && ! [[ "$notdhcp" == "notdhcp" ]];then
#             printf "dynamic IP change notify"
             install_rc
             install_dynIPch
        fi
        if [[ "$answer" =~ p ]];then
            install_port_knocking
        fi
     fi
done

exit
